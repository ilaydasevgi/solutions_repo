{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion is one of the most fundamental topics in classical mechanics. Despite its apparent simplicity, it provides a deep insight into the laws of motion and the effects of initial conditions on trajectory. The central question here is: \"How does the range (horizontal distance traveled) of a projectile depend on the angle at which it is launched?\" By investigating this, we uncover the elegant symmetry in projectile motion and how various physical parameters influence the outcome. 1. Theoretical Foundation We begin with the ideal case of projectile motion: - No air resistance - Constant gravitational acceleration \\( g \\) - Launch from ground level Let: - \\( v_0 \\) : initial launch speed - \\( \\theta \\) : launch angle (in degrees or radians) - \\( g \\) : gravitational acceleration - \\( R \\) : horizontal range - \\( T \\) : time of flight - \\( h = 0 \\) : launch and landing at the same height Equations of Motion Horizontal motion (no acceleration): \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion (accelerated): \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] At \\( y = 0 \\) , the projectile lands, giving total time of flight: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Substitute into \\( x(t) \\) to find range : Range Equation: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that: - The range depends sinusoidally on the angle - Maximum range occurs at \\( \\theta = 45^\\circ \\) - It's symmetric around \\( 45^\\circ \\) (e.g., \\( 30^\\circ \\) and \\( 60^\\circ \\) give same range) 2. Analysis of the Range Effect of Varying Launch Angle: From the formula: \\[ R(\\theta) = \\frac{v_0^2}{g} \\cdot \\sin(2\\theta) \\] We see that: - \\( R(\\theta) = R(90^\\circ - \\theta) \\) - Maximum at \\( \\theta = 45^\\circ \\) Effect of Initial Speed \\( v_0 \\) : Range increases quadratically with speed: \\[ R \\propto v_0^2 \\] Effect of Gravity \\( g \\) : Range is inversely proportional to gravity: \\[ R \\propto \\frac{1}{g} \\] Thus, on the Moon (where \\( g \\) is smaller), the range is longer for the same \\( v_0 \\) . 3. Practical Applications Real-world uses of projectile motion include: Sports : Basketball, soccer, archery (tuning angle for maximum distance) Engineering : Ballistics, cannon design Space physics : Lunar or Mars landings, estimating motion in low gravity More advanced models include: - Launching from an elevated position - Air resistance (drag force) - Wind or spin effects 4. Python Simulation: Range vs Angle We now simulate how the range changes with angle , keeping other parameters constant. Constants: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 500) # launch angles in degrees angles_rad = np.radians(angles_deg) # Function to compute range def compute_range(v0, g, angles_rad): return (v0**2 * np.sin(2 * angles_rad)) / g # Single v0 case v0_single = 20 # m/s range_single = compute_range(v0_single, g, angles_rad) # Multiple v0s for comparison v0_list = [10, 20, 30] ranges_multiple = [compute_range(v, g, angles_rad) for v in v0_list] # Plot: Single Range vs. Angle plt.figure(figsize=(8, 5)) plt.plot(angles_deg, range_single, label=f'v0 = {v0_single} m/s', color='blue') plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Plot: Multiple Initial Velocities plt.figure(figsize=(8, 5)) for i, v0 in enumerate(v0_list): plt.plot(angles_deg, ranges_multiple[i], label=f'v0 = {v0} m/s') plt.title('Range vs. Angle for Different Launch Speeds') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is one of the most fundamental topics in classical mechanics. Despite its apparent simplicity, it provides a deep insight into the laws of motion and the effects of initial conditions on trajectory. The central question here is: \"How does the range (horizontal distance traveled) of a projectile depend on the angle at which it is launched?\" By investigating this, we uncover the elegant symmetry in projectile motion and how various physical parameters influence the outcome.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"We begin with the ideal case of projectile motion: - No air resistance - Constant gravitational acceleration \\( g \\) - Launch from ground level Let: - \\( v_0 \\) : initial launch speed - \\( \\theta \\) : launch angle (in degrees or radians) - \\( g \\) : gravitational acceleration - \\( R \\) : horizontal range - \\( T \\) : time of flight - \\( h = 0 \\) : launch and landing at the same height","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal motion (no acceleration): \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion (accelerated): \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] At \\( y = 0 \\) , the projectile lands, giving total time of flight: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Substitute into \\( x(t) \\) to find range :","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"\\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that: - The range depends sinusoidally on the angle - Maximum range occurs at \\( \\theta = 45^\\circ \\) - It's symmetric around \\( 45^\\circ \\) (e.g., \\( 30^\\circ \\) and \\( 60^\\circ \\) give same range)","title":"Range Equation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-varying-launch-angle","text":"From the formula: \\[ R(\\theta) = \\frac{v_0^2}{g} \\cdot \\sin(2\\theta) \\] We see that: - \\( R(\\theta) = R(90^\\circ - \\theta) \\) - Maximum at \\( \\theta = 45^\\circ \\)","title":"Effect of Varying Launch Angle:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-speed-v_0","text":"Range increases quadratically with speed: \\[ R \\propto v_0^2 \\]","title":"Effect of Initial Speed \\( v_0 \\):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-gravity-g","text":"Range is inversely proportional to gravity: \\[ R \\propto \\frac{1}{g} \\] Thus, on the Moon (where \\( g \\) is smaller), the range is longer for the same \\( v_0 \\) .","title":"Effect of Gravity \\( g \\):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Real-world uses of projectile motion include: Sports : Basketball, soccer, archery (tuning angle for maximum distance) Engineering : Ballistics, cannon design Space physics : Lunar or Mars landings, estimating motion in low gravity More advanced models include: - Launching from an elevated position - Air resistance (drag force) - Wind or spin effects","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-simulation-range-vs-angle","text":"We now simulate how the range changes with angle , keeping other parameters constant.","title":"4. Python Simulation: Range vs Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 500) # launch angles in degrees angles_rad = np.radians(angles_deg) # Function to compute range def compute_range(v0, g, angles_rad): return (v0**2 * np.sin(2 * angles_rad)) / g # Single v0 case v0_single = 20 # m/s range_single = compute_range(v0_single, g, angles_rad) # Multiple v0s for comparison v0_list = [10, 20, 30] ranges_multiple = [compute_range(v, g, angles_rad) for v in v0_list] # Plot: Single Range vs. Angle plt.figure(figsize=(8, 5)) plt.plot(angles_deg, range_single, label=f'v0 = {v0_single} m/s', color='blue') plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Plot: Multiple Initial Velocities plt.figure(figsize=(8, 5)) for i, v0 in enumerate(v0_list): plt.plot(angles_deg, ranges_multiple[i], label=f'v0 = {v0} m/s') plt.title('Range vs. Angle for Different Launch Speeds') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Constants:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum: Theoretical and Computational Analysis Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The equation governing the motion of a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0 = \\sqrt{g/L}\\) for a simple pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force. For small angles ( \\(\\theta \\approx \\sin \\theta\\) ), the equation simplifies to a linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a homogeneous part (damped oscillation) and a particular part (forced oscillation). When the driving frequency approaches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), resonance occurs, leading to large oscillations. 2. Analysis of Dynamics We analyze the system by varying: - Damping coefficient ( \\(\\gamma\\) ) - Driving force amplitude ( \\(A\\) ) - Driving frequency ( \\(\\omega\\) ) Numerical Solution Using Python We use the Runge-Kutta method to solve the system numerically and visualize its dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equations of motion def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions tspan = [0, 50] # Time span y0 = [0.2, 0] # Initial angle and angular velocity # Solve the ODE sol = solve_ivp(forced_damped_pendulum, tspan, y0, args=(gamma, omega0, A, omega), t_eval=np.linspace(0, 50, 1000)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Theta (Angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() 3. Practical Applications The forced damped pendulum model is relevant in: - Energy harvesting devices : Utilizing resonance for energy collection. - Suspension bridges : Understanding oscillatory instabilities. - Oscillating circuits : Analogous behavior in RLC circuits. 4. Phase Portrait and Poincar\u00e9 Section A phase portrait illustrates the evolution of \\((\\theta, \\omega_\\theta)\\) over time, revealing transitions to chaos. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Diferansiyel Denklemi def pendulum(t, state, q, \u03a9, F): \u03b8, \u03c9 = state d\u03b8dt = \u03c9 d\u03c9dt = -q * \u03c9 - np.sin(\u03b8) + F * np.cos(\u03a9 * t) return [d\u03b8dt, d\u03c9dt] # Parametreler q = 0.5 # S\u00f6n\u00fcm katsay\u0131s\u0131 \u03a9 = 2/3 # Zorlanma frekans\u0131 F = 1.2 # Zorlanma kuvveti # Ba\u015flang\u0131\u00e7 ko\u015fullar\u0131: [\u03b8(0), \u03c9(0)] theta_0 = 0.2 omega_0 = 0.0 # Zaman aral\u0131\u011f\u0131 t_span = (0, 50) # 0 ile 50 saniye aras\u0131nda \u00e7\u00f6z\u00fcmle t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1000 zaman noktas\u0131 # \u00c7\u00f6z\u00fcm\u00fc Bul sol = solve_ivp(pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(q, \u03a9, F)) # Faz Portresi \u00c7izimi plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label=\"Faz Uzay\u0131 (\u03b8 vs \u03c9)\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"A\u00e7\u0131sal H\u0131z (rad/s)\") plt.title(\"Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Faz Portresi\") plt.legend() plt.grid() plt.show() 5. Conclusion We explored the dynamics of a forced damped pendulum through theory and simulation. By varying parameters, we observed transitions from periodic motion to chaos. Future work could include: - Introducing nonlinear damping, - Exploring non-periodic driving forces. This study bridges theoretical physics with engineering applications, demonstrating the richness of nonlinear dynamical systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-theoretical-and-computational-analysis","text":"","title":"Forced Damped Pendulum: Theoretical and Computational Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The equation governing the motion of a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0 = \\sqrt{g/L}\\) for a simple pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force. For small angles ( \\(\\theta \\approx \\sin \\theta\\) ), the equation simplifies to a linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a homogeneous part (damped oscillation) and a particular part (forced oscillation). When the driving frequency approaches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), resonance occurs, leading to large oscillations.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"We analyze the system by varying: - Damping coefficient ( \\(\\gamma\\) ) - Driving force amplitude ( \\(A\\) ) - Driving frequency ( \\(\\omega\\) )","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-solution-using-python","text":"We use the Runge-Kutta method to solve the system numerically and visualize its dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equations of motion def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions tspan = [0, 50] # Time span y0 = [0.2, 0] # Initial angle and angular velocity # Solve the ODE sol = solve_ivp(forced_damped_pendulum, tspan, y0, args=(gamma, omega0, A, omega), t_eval=np.linspace(0, 50, 1000)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Theta (Angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Numerical Solution Using Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model is relevant in: - Energy harvesting devices : Utilizing resonance for energy collection. - Suspension bridges : Understanding oscillatory instabilities. - Oscillating circuits : Analogous behavior in RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-phase-portrait-and-poincare-section","text":"A phase portrait illustrates the evolution of \\((\\theta, \\omega_\\theta)\\) over time, revealing transitions to chaos. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Diferansiyel Denklemi def pendulum(t, state, q, \u03a9, F): \u03b8, \u03c9 = state d\u03b8dt = \u03c9 d\u03c9dt = -q * \u03c9 - np.sin(\u03b8) + F * np.cos(\u03a9 * t) return [d\u03b8dt, d\u03c9dt] # Parametreler q = 0.5 # S\u00f6n\u00fcm katsay\u0131s\u0131 \u03a9 = 2/3 # Zorlanma frekans\u0131 F = 1.2 # Zorlanma kuvveti # Ba\u015flang\u0131\u00e7 ko\u015fullar\u0131: [\u03b8(0), \u03c9(0)] theta_0 = 0.2 omega_0 = 0.0 # Zaman aral\u0131\u011f\u0131 t_span = (0, 50) # 0 ile 50 saniye aras\u0131nda \u00e7\u00f6z\u00fcmle t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1000 zaman noktas\u0131 # \u00c7\u00f6z\u00fcm\u00fc Bul sol = solve_ivp(pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(q, \u03a9, F)) # Faz Portresi \u00c7izimi plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label=\"Faz Uzay\u0131 (\u03b8 vs \u03c9)\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"A\u00e7\u0131sal H\u0131z (rad/s)\") plt.title(\"Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Faz Portresi\") plt.legend() plt.grid() plt.show()","title":"4. Phase Portrait and Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-conclusion","text":"We explored the dynamics of a forced damped pendulum through theory and simulation. By varying parameters, we observed transitions from periodic motion to chaos. Future work could include: - Introducing nonlinear damping, - Exploring non-periodic driving forces. This study bridges theoretical physics with engineering applications, demonstrating the richness of nonlinear dynamical systems.","title":"5. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler's Third Law states that the square of the orbital period \\( \\(T\\) \\) of a planet is proportional to the cube of the semi-major axis (orbital radius) \\( \\(r\\) \\) of its orbit. Mathematically: \\[T^2 \\propto r^3\\] This fundamental relationship allows us to: - Predict planetary motions - Calculate planetary masses and distances - Understand gravitational interactions in celestial mechanics 1. Derivation of the Relationship To derive Kepler's Third Law, we start with Newton\u2019s Law of Gravitation: \\[F = \\frac{GMm}{r^2}\\] where: - \\( \\(G\\) \\) is the gravitational constant, - \\( \\(M\\) \\) is the mass of the central body, - \\( \\(m\\) \\) is the mass of the orbiting object, - \\( \\(r\\) \\) is the orbital radius. For circular orbits, the centripetal force is provided by gravity: \\[F = \\frac{m v^2}{r}\\] Equating gravitational force to centripetal force: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Canceling \\( \\(m\\) \\) and rearranging: \\[v^2 = \\frac{GM}{r}\\] The orbital period is given by: \\[T = \\frac{2\\pi r}{v}\\] Substituting \\( \\(v\\) \\) : \\[T = \\frac{2\\pi r}{\\sqrt{GM/r}}\\] Squaring both sides: \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] Thus, we arrive at Kepler's Third Law: \\[T^2 \\propto r^3\\] 2. Implications for Astronomy Kepler's Third Law is crucial in: - Determining planetary masses and distances using observed orbital periods - Satellite and spacecraft navigation - Studying exoplanetary systems Real-World Examples Moon's Orbit Around Earth : Period: \\( \\(T_{moon} \\approx 27.3\\) \\) days Radius: \\( \\(r_{moon} \\approx 3.84 \\times 10^5\\) \\) km Planets in the Solar System : For Earth: \\( \\(T = 1\\) \\) year, \\( \\(r = 1 AU\\) \\) For Mars: \\( \\(T = 1.88\\) \\) years, \\( \\(r = 1.52 AU\\) \\) (follows \\( \\(T^2 \\propto r^3\\) \\) ) 3. Computational Simulation of Circular Orbits Below is a Python script that simulates circular orbits and verifies Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # 1 Astronomical Unit in meters # Function to compute orbital period def orbital_period(r, M): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital radii in AU radii_AU = np.linspace(0.1, 5, 10) radii_m = radii_AU * AU # Compute periods periods = orbital_period(radii_m, M_sun) / (60 * 60 * 24 * 365) # Convert to years # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii_m**3, periods**2, 'bo-', label='$T^2$ vs $r^3$') plt.xlabel('$r^3$ (m^3)') plt.ylabel('$T^2$ (years^2)') plt.title('Verification of Kepler\\'s Third Law') plt.legend() plt.grid() plt.show() 4. Extension to Elliptical Orbits Kepler's Third Law also applies to elliptical orbits , where: \\(r\\) is replaced by the semi-major axis \\(a\\) The relationship still holds: \\( \\(T^2 \\propto a^3\\) \\) This generalization allows for: - Understanding cometary orbits (e.g., Halley's Comet) - Studying binary star systems - Determining galactic dynamics Conclusion Kepler's Third Law provides a direct link between orbital periods and radii. It helps predict planetary motions and system dynamics . Computational models confirm the theoretical relationship. The law extends to elliptical orbits and cosmic scales . References Kepler, J. Astronomia Nova (1609) Newton, I. Principia Mathematica (1687) NASA Planetary Data","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law states that the square of the orbital period \\( \\(T\\) \\) of a planet is proportional to the cube of the semi-major axis (orbital radius) \\( \\(r\\) \\) of its orbit. Mathematically: \\[T^2 \\propto r^3\\] This fundamental relationship allows us to: - Predict planetary motions - Calculate planetary masses and distances - Understand gravitational interactions in celestial mechanics","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-the-relationship","text":"To derive Kepler's Third Law, we start with Newton\u2019s Law of Gravitation: \\[F = \\frac{GMm}{r^2}\\] where: - \\( \\(G\\) \\) is the gravitational constant, - \\( \\(M\\) \\) is the mass of the central body, - \\( \\(m\\) \\) is the mass of the orbiting object, - \\( \\(r\\) \\) is the orbital radius. For circular orbits, the centripetal force is provided by gravity: \\[F = \\frac{m v^2}{r}\\] Equating gravitational force to centripetal force: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Canceling \\( \\(m\\) \\) and rearranging: \\[v^2 = \\frac{GM}{r}\\] The orbital period is given by: \\[T = \\frac{2\\pi r}{v}\\] Substituting \\( \\(v\\) \\) : \\[T = \\frac{2\\pi r}{\\sqrt{GM/r}}\\] Squaring both sides: \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] Thus, we arrive at Kepler's Third Law: \\[T^2 \\propto r^3\\]","title":"1. Derivation of the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler's Third Law is crucial in: - Determining planetary masses and distances using observed orbital periods - Satellite and spacecraft navigation - Studying exoplanetary systems","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"Moon's Orbit Around Earth : Period: \\( \\(T_{moon} \\approx 27.3\\) \\) days Radius: \\( \\(r_{moon} \\approx 3.84 \\times 10^5\\) \\) km Planets in the Solar System : For Earth: \\( \\(T = 1\\) \\) year, \\( \\(r = 1 AU\\) \\) For Mars: \\( \\(T = 1.88\\) \\) years, \\( \\(r = 1.52 AU\\) \\) (follows \\( \\(T^2 \\propto r^3\\) \\) )","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-computational-simulation-of-circular-orbits","text":"Below is a Python script that simulates circular orbits and verifies Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # 1 Astronomical Unit in meters # Function to compute orbital period def orbital_period(r, M): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital radii in AU radii_AU = np.linspace(0.1, 5, 10) radii_m = radii_AU * AU # Compute periods periods = orbital_period(radii_m, M_sun) / (60 * 60 * 24 * 365) # Convert to years # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii_m**3, periods**2, 'bo-', label='$T^2$ vs $r^3$') plt.xlabel('$r^3$ (m^3)') plt.ylabel('$T^2$ (years^2)') plt.title('Verification of Kepler\\'s Third Law') plt.legend() plt.grid() plt.show()","title":"3. Computational Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-extension-to-elliptical-orbits","text":"Kepler's Third Law also applies to elliptical orbits , where: \\(r\\) is replaced by the semi-major axis \\(a\\) The relationship still holds: \\( \\(T^2 \\propto a^3\\) \\) This generalization allows for: - Understanding cometary orbits (e.g., Halley's Comet) - Studying binary star systems - Determining galactic dynamics","title":"4. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law provides a direct link between orbital periods and radii. It helps predict planetary motions and system dynamics . Computational models confirm the theoretical relationship. The law extends to elliptical orbits and cosmic scales .","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","text":"Kepler, J. Astronomia Nova (1609) Newton, I. Principia Mathematica (1687) NASA Planetary Data","title":"References"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. 1. Definitions of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) The minimum velocity required for a body to stay in a stable circular orbit around a celestial body. Derived using centripetal force balance with gravitational force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The minimum velocity required to escape a celestial body\u2019s gravitational field. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity (Solar System Escape Velocity) The minimum velocity required to escape both the planet\u2019s gravity and the Sun\u2019s gravitational influence. Derived from combining the escape velocity of the planet and the escape velocity from the Sun: $$ v_3 = \\sqrt{v_{\\text{escape, planet}}^2 + v_{\\text{escape, sun}}^2} $$ 2. Mathematical Derivations and Parameters Affecting These Velocities Gravitational constant (G) : \\( 6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) Mass of celestial body (M) Radius of celestial body (R) For third cosmic velocity, Sun's mass and distance are also considered. 3. Python Code to Calculate and Visualize Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in m) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Compute velocities velocities = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots(figsize=(8, 6)) x_labels = list(velocities.keys()) v1_vals = [velocities[body][0] for body in x_labels] v2_vals = [velocities[body][1] for body in x_labels] ax.bar(x_labels, v1_vals, label=\"First Cosmic Velocity (km/s)\", color=\"blue\") ax.bar(x_labels, v2_vals, label=\"Second Cosmic Velocity (km/s)\", color=\"red\", alpha=0.7) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"First and Second Cosmic Velocities for Celestial Bodies\") ax.legend() plt.show() 4. Discussion on Space Exploration Satellites : Launched at first cosmic velocity to remain in orbit. Interplanetary Missions : Rockets must reach at least second cosmic velocity to escape Earth's gravity. Interstellar Travel : Requires surpassing the third cosmic velocity to leave the Sun\u2019s gravitational influence.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-of-cosmic-velocities","text":"","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The minimum velocity required for a body to stay in a stable circular orbit around a celestial body. Derived using centripetal force balance with gravitational force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The minimum velocity required to escape a celestial body\u2019s gravitational field. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-solar-system-escape-velocity","text":"The minimum velocity required to escape both the planet\u2019s gravity and the Sun\u2019s gravitational influence. Derived from combining the escape velocity of the planet and the escape velocity from the Sun: $$ v_3 = \\sqrt{v_{\\text{escape, planet}}^2 + v_{\\text{escape, sun}}^2} $$","title":"Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations-and-parameters-affecting-these-velocities","text":"Gravitational constant (G) : \\( 6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) Mass of celestial body (M) Radius of celestial body (R) For third cosmic velocity, Sun's mass and distance are also considered.","title":"2. Mathematical Derivations and Parameters Affecting These Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-to-calculate-and-visualize-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in m) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Compute velocities velocities = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots(figsize=(8, 6)) x_labels = list(velocities.keys()) v1_vals = [velocities[body][0] for body in x_labels] v2_vals = [velocities[body][1] for body in x_labels] ax.bar(x_labels, v1_vals, label=\"First Cosmic Velocity (km/s)\", color=\"blue\") ax.bar(x_labels, v2_vals, label=\"Second Cosmic Velocity (km/s)\", color=\"red\", alpha=0.7) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"First and Second Cosmic Velocities for Celestial Bodies\") ax.legend() plt.show()","title":"3. Python Code to Calculate and Visualize Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-discussion-on-space-exploration","text":"Satellites : Launched at first cosmic velocity to remain in orbit. Interplanetary Missions : Rockets must reach at least second cosmic velocity to escape Earth's gravity. Interstellar Travel : Requires surpassing the third cosmic velocity to leave the Sun\u2019s gravitational influence.","title":"4. Discussion on Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Before diving into theory, explore how real spacecraft move using NASA\u2019s official 3D simulation platform: \ud83c\udf10 NASA Eyes on the Solar System Real-time orbits, mission tracking, and gravity interactions! Motivation When a payload is released from a moving rocket near Earth, it can follow a wide range of trajectories based on its initial speed, direction, and altitude . These can include: Reentry into Earth\u2019s atmosphere, Stable orbits (elliptical or circular), Escape into space. Understanding these trajectories is crucial for: Satellite deployment, Reentry planning, Interplanetary missions. This problem blends orbital mechanics with numerical simulation , providing practical insight into real-world space mission planning. Governing Physics To better understand gravitational attraction and orbital motion, you can explore this interactive simulation: \ud83c\udf10 PhET: Gravity and Orbits Visualize how mass, distance, and velocity affect planetary orbits and satellite motion in real time! Newton\u2019s Law of Universal Gravitation The gravitational force acting on a payload is: \\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\( G = 6.674 \\times 10^{-11} \\, \\text{m}^3/\\text{kg} \\cdot \\text{s}^2 \\) is the gravitational constant, \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) is Earth\u2019s mass, \\( m \\) is the mass of the payload (cancels out later), \\( r \\) is the distance between Earth\u2019s center and the payload, \\( \\hat{r} \\) is the unit vector pointing toward Earth\u2019s center. Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = -\\frac{GM}{r^2} \\hat{r} \\] This gives us the acceleration at any point, which we use for simulation. Orbital Energy and Trajectories Total specific mechanical energy of the payload: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\( \\epsilon < 0 \\) : Elliptical orbit (bound) \\( \\epsilon = 0 \\) : Parabolic trajectory (escape) \\( \\epsilon > 0 \\) : Hyperbolic trajectory (escape) Escape velocity at distance \\( r \\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Escape velocity decreases with altitude since gravitational pull weakens. It is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Below is a plot showing how escape velocity changes with altitude: Numerical Simulation (Euler Method) We use the Euler method to simulate the motion of the payload. It updates position and velocity step-by-step using: \\[ \\vec{v}_{n+1} = \\vec{v}_n + \\vec{a}_n \\cdot \\Delta t \\] \\[ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_{n+1} \\cdot \\Delta t \\] Assumptions: Earth is a point mass at origin. Motion is in 2D space (x, y). Only gravity affects the payload (no atmosphere, drag, etc.). Python Implementation Google Collab Link For Python Implementation \ud83d\udd0d Explore Further: Beyond Earth While this project focuses on payloads near Earth, it's also valuable to understand more complex gravitational dynamics. \ud83c\udfa5 SkyMarvels\u2122 \u2013 Solar System Barycenter How the Sun moves due to gravitational pulls from the planets \u2014 visualized with Celestia. Barycenters explain why the Sun itself moves slightly \u2014 important for understanding motion in multi-body systems.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"Before diving into theory, explore how real spacecraft move using NASA\u2019s official 3D simulation platform: \ud83c\udf10 NASA Eyes on the Solar System Real-time orbits, mission tracking, and gravity interactions!","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, it can follow a wide range of trajectories based on its initial speed, direction, and altitude . These can include: Reentry into Earth\u2019s atmosphere, Stable orbits (elliptical or circular), Escape into space. Understanding these trajectories is crucial for: Satellite deployment, Reentry planning, Interplanetary missions. This problem blends orbital mechanics with numerical simulation , providing practical insight into real-world space mission planning.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-physics","text":"To better understand gravitational attraction and orbital motion, you can explore this interactive simulation: \ud83c\udf10 PhET: Gravity and Orbits Visualize how mass, distance, and velocity affect planetary orbits and satellite motion in real time!","title":"Governing Physics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-universal-gravitation","text":"The gravitational force acting on a payload is: \\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\( G = 6.674 \\times 10^{-11} \\, \\text{m}^3/\\text{kg} \\cdot \\text{s}^2 \\) is the gravitational constant, \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) is Earth\u2019s mass, \\( m \\) is the mass of the payload (cancels out later), \\( r \\) is the distance between Earth\u2019s center and the payload, \\( \\hat{r} \\) is the unit vector pointing toward Earth\u2019s center. Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = -\\frac{GM}{r^2} \\hat{r} \\] This gives us the acceleration at any point, which we use for simulation.","title":"Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-energy-and-trajectories","text":"Total specific mechanical energy of the payload: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\( \\epsilon < 0 \\) : Elliptical orbit (bound) \\( \\epsilon = 0 \\) : Parabolic trajectory (escape) \\( \\epsilon > 0 \\) : Hyperbolic trajectory (escape) Escape velocity at distance \\( r \\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Escape velocity decreases with altitude since gravitational pull weakens. It is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Below is a plot showing how escape velocity changes with altitude:","title":"Orbital Energy and Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-euler-method","text":"We use the Euler method to simulate the motion of the payload. It updates position and velocity step-by-step using: \\[ \\vec{v}_{n+1} = \\vec{v}_n + \\vec{a}_n \\cdot \\Delta t \\] \\[ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_{n+1} \\cdot \\Delta t \\]","title":"Numerical Simulation (Euler Method)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#assumptions","text":"Earth is a point mass at origin. Motion is in 2D space (x, y). Only gravity affects the payload (no atmosphere, drag, etc.).","title":"Assumptions:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"Google Collab Link For Python Implementation","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explore-further-beyond-earth","text":"While this project focuses on payloads near Earth, it's also valuable to understand more complex gravitational dynamics. \ud83c\udfa5 SkyMarvels\u2122 \u2013 Solar System Barycenter How the Sun moves due to gravitational pulls from the planets \u2014 visualized with Celestia. Barycenters explain why the Sun itself moves slightly \u2014 important for understanding motion in multi-body systems.","title":"\ud83d\udd0d Explore Further: Beyond Earth"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from multiple sources overlap in space, creating new wave patterns. On a water surface, this is easily observed when circular ripples from different points intersect, producing interference patterns . These patterns reveal: Constructive interference : where waves reinforce each other Destructive interference : where waves cancel each other Studying such patterns helps us understand: Superposition principle Phase relationships between waves Real-world wave interactions Problem Statement We aim to simulate and analyze the interference pattern created by circular waves emitted from coherent point sources located at the vertices of a regular polygon . Theoretical Background Single Circular Wave The disturbance caused by a single point source at position \\( (x_0, y_0) \\) on the water surface is modeled by: \\[ u(x, y, t) = A \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\( u(x, y, t) \\) : Displacement at position \\( (x, y) \\) and time \\( t \\) \\( A \\) : Amplitude \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number \\( \\lambda \\) : Wavelength \\( \\omega = 2\\pi f \\) : Angular frequency \\( f \\) : Frequency \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : Distance from source to point \\( \\phi \\) : Initial phase Superposition of Waves If there are \\( N \\) identical, coherent wave sources, the total displacement at any point \\( (x, y) \\) is: \\[ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : Distance from the \\( i^\\text{th} \\) source to point \\( (x, y) \\) Simulation: Square Configuration (4 Sources) We simulate 4 point sources placed at the vertices of a square , centered at the origin. Simulation Parameters Polygon type: Square (4 vertices) Radius \\( R = 1 \\) Amplitude \\( A = 1 \\) Wavelength \\( \\lambda = 1 \\) Frequency \\( f = 1 \\) Phase \\( \\phi = 0 \\) Time snapshot \\( t = 0 \\) Python Code The following Python script simulates the interference pattern produced by four coherent wave sources placed at the vertices of a square , centered at the origin. Each source emits circular waves with the same amplitude, wavelength, and frequency. The wave equation used for each point source is: \\[ u(x, y, t) = A \\cdot \\cos(k r - \\omega t + \\phi) \\] The total displacement is calculated by the superposition of waves from all sources: \\[ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Here\u2019s the full Python implementation: import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 wavelength = 1 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t = 0 # single time snapshot # Grid setup x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Square: 4 vertices on a circle N = 4 R = 1 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] # Superposition of waves Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * r - omega * t + phi) # Plotting plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, Z, shading='auto', cmap='RdBu') plt.colorbar(label='Water Surface Displacement $u(x, y)$') plt.scatter(*zip(*sources), color='black', marker='o', label='Sources') plt.title('Interference Pattern from 4 Point Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.tight_layout() plt.show() Extensions (Link to Google Collab Simulation) https://colab.research.google.com/drive/1MZGHTR9STk3OZIWyuUVt4DeySR8lZ-JC?authuser=0","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from multiple sources overlap in space, creating new wave patterns. On a water surface, this is easily observed when circular ripples from different points intersect, producing interference patterns . These patterns reveal: Constructive interference : where waves reinforce each other Destructive interference : where waves cancel each other Studying such patterns helps us understand: Superposition principle Phase relationships between waves Real-world wave interactions","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"We aim to simulate and analyze the interference pattern created by circular waves emitted from coherent point sources located at the vertices of a regular polygon .","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-circular-wave","text":"The disturbance caused by a single point source at position \\( (x_0, y_0) \\) on the water surface is modeled by: \\[ u(x, y, t) = A \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\( u(x, y, t) \\) : Displacement at position \\( (x, y) \\) and time \\( t \\) \\( A \\) : Amplitude \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number \\( \\lambda \\) : Wavelength \\( \\omega = 2\\pi f \\) : Angular frequency \\( f \\) : Frequency \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : Distance from source to point \\( \\phi \\) : Initial phase","title":"Single Circular Wave"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"If there are \\( N \\) identical, coherent wave sources, the total displacement at any point \\( (x, y) \\) is: \\[ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : Distance from the \\( i^\\text{th} \\) source to point \\( (x, y) \\)","title":"Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-square-configuration-4-sources","text":"We simulate 4 point sources placed at the vertices of a square , centered at the origin.","title":"Simulation: Square Configuration (4 Sources)"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-parameters","text":"Polygon type: Square (4 vertices) Radius \\( R = 1 \\) Amplitude \\( A = 1 \\) Wavelength \\( \\lambda = 1 \\) Frequency \\( f = 1 \\) Phase \\( \\phi = 0 \\) Time snapshot \\( t = 0 \\)","title":"Simulation Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"The following Python script simulates the interference pattern produced by four coherent wave sources placed at the vertices of a square , centered at the origin. Each source emits circular waves with the same amplitude, wavelength, and frequency. The wave equation used for each point source is: \\[ u(x, y, t) = A \\cdot \\cos(k r - \\omega t + \\phi) \\] The total displacement is calculated by the superposition of waves from all sources: \\[ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Here\u2019s the full Python implementation: import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 wavelength = 1 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t = 0 # single time snapshot # Grid setup x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Square: 4 vertices on a circle N = 4 R = 1 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] # Superposition of waves Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * r - omega * t + phi) # Plotting plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, Z, shading='auto', cmap='RdBu') plt.colorbar(label='Water Surface Displacement $u(x, y)$') plt.scatter(*zip(*sources), color='black', marker='o', label='Sources') plt.title('Interference Pattern from 4 Point Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#extensions","text":"(Link to Google Collab Simulation) https://colab.research.google.com/drive/1MZGHTR9STk3OZIWyuUVt4DeySR8lZ-JC?authuser=0","title":"Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force is a fundamental concept in electromagnetism and charged particle dynamics. It describes how a charged particle moves under the influence of electric and magnetic fields. The force is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\( \\vec{F} \\) is the total force on the particle \\( q \\) is the charge \\( \\vec{E} \\) is the electric field \\( \\vec{v} \\) is the velocity of the particle \\( \\vec{B} \\) is the magnetic field The Lorentz force governs the motion of charged particles in a variety of physical systems, including: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement in fusion devices (e.g., tokamaks) Astrophysical environments (e.g., solar wind, magnetospheres) Applications of the Lorentz Force Particle Accelerators Charged particles are steered and accelerated using magnetic and electric fields based on Lorentz force dynamics. Mass Spectrometers Particles with different mass-to-charge ratios follow different curved paths in a magnetic field, enabling identification. Plasma Confinement Magnetic fields are used to confine hot plasmas in devices like tokamaks , where charged particles spiral and drift in controlled ways. Theory and Equations of Motion The motion of a charged particle under Lorentz force follows Newton's second law: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This is a system of coupled differential equations that can be solved numerically using methods like Euler's method or Runge-Kutta . Python Simulation: Lorentz Force We simulate three cases: Uniform Magnetic Field (Only \\( \\vec{B} \\) ) Combined Uniform Electric and Magnetic Fields Crossed \\( \\vec{E} \\perp \\vec{B} \\) Fields Parameters: Charge \\( q = 1 \\) C Mass \\( m = 1 \\) kg Initial velocity \\( \\vec{v}_0 = (v_x, v_y, v_z) \\) Fields: \\( \\vec{B} = (0, 0, B_z) \\) \\( \\vec{E} = (E_x, 0, 0) \\) Euler Integration Function import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, m, E, B, v0, r0, dt, steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt return r, v Interactive Lorentz Force Simulations Explore these online tools to interactively understand the Lorentz force: PhET: Charges and Fields Falstad: Magnetic Field Force Simulator MyPhysicsLab: Lorentz Force These visual tools can help you explore the vector nature of force, circular motion in B-fields, and drift dynamics in crossed fields.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force is a fundamental concept in electromagnetism and charged particle dynamics. It describes how a charged particle moves under the influence of electric and magnetic fields. The force is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\( \\vec{F} \\) is the total force on the particle \\( q \\) is the charge \\( \\vec{E} \\) is the electric field \\( \\vec{v} \\) is the velocity of the particle \\( \\vec{B} \\) is the magnetic field The Lorentz force governs the motion of charged particles in a variety of physical systems, including: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement in fusion devices (e.g., tokamaks) Astrophysical environments (e.g., solar wind, magnetospheres)","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-the-lorentz-force","text":"Particle Accelerators Charged particles are steered and accelerated using magnetic and electric fields based on Lorentz force dynamics. Mass Spectrometers Particles with different mass-to-charge ratios follow different curved paths in a magnetic field, enabling identification. Plasma Confinement Magnetic fields are used to confine hot plasmas in devices like tokamaks , where charged particles spiral and drift in controlled ways.","title":"Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#theory-and-equations-of-motion","text":"The motion of a charged particle under Lorentz force follows Newton's second law: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This is a system of coupled differential equations that can be solved numerically using methods like Euler's method or Runge-Kutta .","title":"Theory and Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-lorentz-force","text":"We simulate three cases: Uniform Magnetic Field (Only \\( \\vec{B} \\) ) Combined Uniform Electric and Magnetic Fields Crossed \\( \\vec{E} \\perp \\vec{B} \\) Fields","title":"Python Simulation: Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"Charge \\( q = 1 \\) C Mass \\( m = 1 \\) kg Initial velocity \\( \\vec{v}_0 = (v_x, v_y, v_z) \\) Fields: \\( \\vec{B} = (0, 0, B_z) \\) \\( \\vec{E} = (E_x, 0, 0) \\)","title":"Parameters:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#euler-integration-function","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, m, E, B, v0, r0, dt, steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt return r, v","title":"Euler Integration Function"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#interactive-lorentz-force-simulations","text":"Explore these online tools to interactively understand the Lorentz force: PhET: Charges and Fields Falstad: Magnetic Field Force Simulator MyPhysicsLab: Lorentz Force These visual tools can help you explore the vector nature of force, circular motion in B-fields, and drift dynamics in crossed fields.","title":"Interactive Lorentz Force Simulations"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}