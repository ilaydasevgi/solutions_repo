{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Motivation Projectile motion, while seemingly simple, provides a rich foundation for understanding fundamental physics principles. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. However, beneath this simplicity lies a complex framework involving both linear and quadratic relationships. This topic is particularly compelling due to the number of free parameters involved, such as: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch height \\(h\\) These parameters give rise to a diverse set of solutions that describe real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. 2. Theoretical Foundation To analyze projectile motion, we derive the governing equations from fundamental principles, primarily Newton's second law of motion. 2.1. Equations of Motion Projectile motion is governed by Newton\u2019s Second Law: \\(F = m \\cdot a\\) For a projectile, forces acting on the object include: 1. Gravity ( \\(mg\\) ) in the vertical direction. 2. No horizontal forces (ignoring air resistance initially). Thus, the acceleration components are: \\(a_x = 0, \\quad a_y = -g\\) Integrating these equations, we obtain the velocity components: \\(v_x = v_0 \\cos(\\theta), \\quad v_y = v_0 \\sin(\\theta) - g t\\) Further integration gives the position equations: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) The horizontal and vertical motion of a projectile are governed by kinematic equations: Horizontal motion (constant velocity): \\[x(t) = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated motion due to gravity): \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\] where: \\(x(t)\\) and \\(y(t)\\) are the projectile's position at time \\(t\\) . \\(v_0\\) is the initial velocity. \\(\\theta\\) is the launch angle. \\(g\\) is the gravitational acceleration (typically 9.81 m/s\u00b2 on Earth). These fundamental equations describe projectile motion and will now be used to analyze range and time of flight. 2.2. Time of Flight The total time the projectile spends in the air can be determined by setting \\(y(t) = 0\\) : \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\) 2.3. Range Equation The range \\(R\\) is the total horizontal distance traveled before the projectile lands. Using \\(t_f\\) in the horizontal motion equation: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the trigonometric identity \\(2\\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we obtain: \\(R(\\theta) = \\frac{v_0^2}{g} \\sin(2\\theta)\\) 2.4. Maximum Range The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, which happens at \\(\\theta = 45^\\circ\\) : \\(R_{max} = \\frac{v_0^2}{g}\\) 3. Analysis of the Range 3.1. Dependence on Angle The range follows a symmetrical pattern around \\(\\theta = 45^\\circ\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) result in the same range. 3.2. Effect of Initial Velocity Higher \\(v_0\\) leads to a longer range, proportional to \\(v_0^2\\) . 3.3. Effect of Gravity A larger \\(g\\) (such as on Jupiter) reduces range, while a smaller \\(g\\) (such as on the Moon) increases it. \ud83d\udccc Improved Range Plot with Annotations import numpy as np import matplotlib.pyplot as plt # Define parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s^2) theta = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees # Compute range R = (v0**2 * np.sin(np.deg2rad(2 * theta))) / g # Plot the range vs. angle plt.figure(figsize=(10, 6)) plt.plot(theta, R, label='Range (R)', color='blue') # Mark the maximum range at 45\u00b0 plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.text(46, max(R)-2, \"Maximum Range\", color='red') plt.xlabel('Projection Angle (\u03b8) [Degrees]') plt.ylabel('Range (R) [m]') plt.title('Projectile Range as a Function of Launch Angle') plt.grid(True) plt.legend() plt.show() 4. Implementation: Python Visualization We implement a computational tool to visualize the range as a function of the angle. \ud83d\ude80 Projectile Motion Simulation This simulation demonstrates the parabolic trajectory of a projectile launched at a given angle and velocity. Users can adjust the launch angle and initial speed , allowing them to observe how different conditions affect projectile motion. \ud83d\udccc How It Works? The user selects a launch angle (0\u00b0 - 90\u00b0) and initial velocity (5 - 50 m/s) . Pressing the \"Start Simulation\" button runs the animation based on the selected values. A moving particle (blue dot) follows a curved trajectory due to gravity . The graph dynamically updates to show the horizontal and vertical motion. \ud83d\udda5 Use Cases \u2705 Understanding projectile motion in physics courses. \u2705 Basic modeling for engineering and ballistic calculations. \u2705 Trajectory analysis for real-world problems. \ud83d\udd17 Run the Simulation on Google Colab: Link text 5. Air Resistance & Improved Models In reality, projectiles experience air resistance proportional to velocity: \\(F_{drag} = - k v^2\\) The equations of motion now become: \\(a_x = -\\frac{k}{m} v_x, \\quad a_y = -g - \\frac{k}{m} v_y\\) \ud83d\udccc Visualization with Air Resistance import numpy as np import matplotlib.pyplot as plt # Projectile parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) g = 9.81 # Gravitational acceleration (m/s^2) mass = 0.5 # Mass of the object (kg) drag_coefficient = 0.1 # Air resistance coefficient (kg/m) # Helper functions def trajectory_no_air_resistance(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient, dt=0.01): angle_rad = np.radians(angle) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, 0 x_positions, y_positions = [x], [y] while y >= 0: ax = -drag_coefficient * vx / mass ay = -g - (drag_coefficient * vy / mass) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_positions.append(x) y_positions.append(y) return x_positions, y_positions # Simulation time for the case without air resistance t_max = 2 * v0 * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, num=500) # Calculations x_no_air, y_no_air = trajectory_no_air_resistance(v0, angle, g, t) x_with_air, y_with_air = trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient) # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air, y_no_air, label=\"Without air resistance\", linestyle=\"--\") plt.plot(x_with_air, y_with_air, label=\"With air resistance\", linestyle=\"-\") plt.title(\"Projectile motion: comparison with and without air resistance\") plt.xlabel(\"Distance (m)\") plt.ylabel(\"Height (m)\") plt.legend() plt.grid() plt.show() ## Projectile Motion with and Without Air Resistance (with Bouncing) 1\ufe0f\u20e3 What Does This Code Do? This Python script simulates and visualizes projectile motion with and without air resistance, including bounces off the ground. The animation shows how air resistance affects the motion of a projectile compared to the idealized case with no drag. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters m = 1.0 # Mass [kg] g = 9.81 # Gravitational acceleration [m/s^2] k = 0.1 # Air resistance coefficient [kg/s] v0 = 20 # Initial velocity [m/s] theta = np.radians(45) # Initial angle [degrees -> radians] dt = 0.02 # Time step [s] T = 5 # Simulation time [s] elasticity = 0.7 # Coefficient of restitution # Function to calculate trajectory without air resistance def trajectory_no_drag(v0, theta, g, dt, T, elasticity): x, y = [0], [0] vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) t = 0 while t < T: x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt - 0.5 * g * dt**2 vy -= g * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Function to calculate trajectory with air resistance def trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity): vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = [0], [0] t = 0 while t < T: ax = - (k / m) * vx ay = -g - (k / m) * vy vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Compute trajectories x_no_drag, y_no_drag = trajectory_no_drag(v0, theta, g, dt, T, elasticity) x_drag, y_drag = trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity) # Initialize animation fig, ax = plt.subplots(figsize=(8, 5)) ax.set_xlim(0, max(max(x_no_drag), max(x_drag))) ax.set_ylim(0, max(max(y_no_drag), max(y_drag))) ax.set_xlabel(\"Distance [m]\") ax.set_ylabel(\"Height [m]\") ax.set_title(\"Projectile motion with and without air resistance (with bounces)\") ax.grid() point_no_drag, = ax.plot([], [], 'bo', label=\"Without air resistance\") point_drag, = ax.plot([], [], 'ro', label=\"With air resistance\") traj_no_drag, = ax.plot([], [], 'b--', alpha=0.5) traj_drag, = ax.plot([], [], 'r--', alpha=0.5) ax.legend() # Initialization function def init(): point_no_drag.set_data([], []) point_drag.set_data([], []) traj_no_drag.set_data([], []) traj_drag.set_data([], []) return point_no_drag, point_drag, traj_no_drag, traj_drag # Function to update the animation def update(frame): if frame < len(x_no_drag): point_no_drag.set_data([x_no_drag[frame]], [y_no_drag[frame]]) traj_no_drag.set_data(x_no_drag[:frame+1], y_no_drag[:frame+1]) if frame < len(x_drag): point_drag.set_data([x_drag[frame]], [y_drag[frame]]) traj_drag.set_data(x_drag[:frame+1], y_drag[:frame+1]) return point_no_drag, point_drag, traj_no_drag, traj_drag # Create animation frames = max(len(x_no_drag), len(x_drag)) ani = FuncAnimation(fig, update, frames=frames, init_func=init, blit=False, interval=20) # Display animation in Colab plt.close() HTML(ani.to_html5_video()) Link To The Simulation Above On Google Colab https://colab.research.google.com/drive/1JAPKrMDEgJBFYaxuZgfnd50JqxAKGi-t?usp=sharing 7. Conclusion The range equation follows a clear mathematical pattern. Maximum range occurs at 45\u00b0 , confirmed analytically and numerically. Including air resistance shows a significant reduction in range . This study has applications in sports, engineering, and physics simulations. 8. References & Further Reading Resnick, R., & Halliday, D. (2004). Fundamentals of Physics . MIT OpenCourseWare: Classical Mechanics Lectures. NASA\u2019s trajectory analysis for spacecraft launches.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motivation","text":"Projectile motion, while seemingly simple, provides a rich foundation for understanding fundamental physics principles. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. However, beneath this simplicity lies a complex framework involving both linear and quadratic relationships. This topic is particularly compelling due to the number of free parameters involved, such as: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch height \\(h\\) These parameters give rise to a diverse set of solutions that describe real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"1. Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"To analyze projectile motion, we derive the governing equations from fundamental principles, primarily Newton's second law of motion.","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-equations-of-motion","text":"Projectile motion is governed by Newton\u2019s Second Law: \\(F = m \\cdot a\\) For a projectile, forces acting on the object include: 1. Gravity ( \\(mg\\) ) in the vertical direction. 2. No horizontal forces (ignoring air resistance initially). Thus, the acceleration components are: \\(a_x = 0, \\quad a_y = -g\\) Integrating these equations, we obtain the velocity components: \\(v_x = v_0 \\cos(\\theta), \\quad v_y = v_0 \\sin(\\theta) - g t\\) Further integration gives the position equations: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) The horizontal and vertical motion of a projectile are governed by kinematic equations: Horizontal motion (constant velocity): \\[x(t) = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated motion due to gravity): \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\] where: \\(x(t)\\) and \\(y(t)\\) are the projectile's position at time \\(t\\) . \\(v_0\\) is the initial velocity. \\(\\theta\\) is the launch angle. \\(g\\) is the gravitational acceleration (typically 9.81 m/s\u00b2 on Earth). These fundamental equations describe projectile motion and will now be used to analyze range and time of flight.","title":"2.1. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-time-of-flight","text":"The total time the projectile spends in the air can be determined by setting \\(y(t) = 0\\) : \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\)","title":"2.2. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#23-range-equation","text":"The range \\(R\\) is the total horizontal distance traveled before the projectile lands. Using \\(t_f\\) in the horizontal motion equation: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the trigonometric identity \\(2\\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we obtain: \\(R(\\theta) = \\frac{v_0^2}{g} \\sin(2\\theta)\\)","title":"2.3. Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#24-maximum-range","text":"The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, which happens at \\(\\theta = 45^\\circ\\) : \\(R_{max} = \\frac{v_0^2}{g}\\)","title":"2.4. Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analysis-of-the-range","text":"","title":"3. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-dependence-on-angle","text":"The range follows a symmetrical pattern around \\(\\theta = 45^\\circ\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) result in the same range.","title":"3.1. Dependence on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-effect-of-initial-velocity","text":"Higher \\(v_0\\) leads to a longer range, proportional to \\(v_0^2\\) .","title":"3.2. Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-effect-of-gravity","text":"A larger \\(g\\) (such as on Jupiter) reduces range, while a smaller \\(g\\) (such as on the Moon) increases it.","title":"3.3. Effect of Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#improved-range-plot-with-annotations","text":"import numpy as np import matplotlib.pyplot as plt # Define parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s^2) theta = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees # Compute range R = (v0**2 * np.sin(np.deg2rad(2 * theta))) / g # Plot the range vs. angle plt.figure(figsize=(10, 6)) plt.plot(theta, R, label='Range (R)', color='blue') # Mark the maximum range at 45\u00b0 plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.text(46, max(R)-2, \"Maximum Range\", color='red') plt.xlabel('Projection Angle (\u03b8) [Degrees]') plt.ylabel('Range (R) [m]') plt.title('Projectile Range as a Function of Launch Angle') plt.grid(True) plt.legend() plt.show()","title":"\ud83d\udccc Improved Range Plot with Annotations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-visualization","text":"We implement a computational tool to visualize the range as a function of the angle.","title":"4. Implementation: Python Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-simulation","text":"This simulation demonstrates the parabolic trajectory of a projectile launched at a given angle and velocity. Users can adjust the launch angle and initial speed , allowing them to observe how different conditions affect projectile motion.","title":"\ud83d\ude80 Projectile Motion Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#how-it-works","text":"The user selects a launch angle (0\u00b0 - 90\u00b0) and initial velocity (5 - 50 m/s) . Pressing the \"Start Simulation\" button runs the animation based on the selected values. A moving particle (blue dot) follows a curved trajectory due to gravity . The graph dynamically updates to show the horizontal and vertical motion.","title":"\ud83d\udccc How It Works?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#use-cases","text":"\u2705 Understanding projectile motion in physics courses. \u2705 Basic modeling for engineering and ballistic calculations. \u2705 Trajectory analysis for real-world problems. \ud83d\udd17 Run the Simulation on Google Colab: Link text","title":"\ud83d\udda5 Use Cases"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-air-resistance-improved-models","text":"In reality, projectiles experience air resistance proportional to velocity: \\(F_{drag} = - k v^2\\) The equations of motion now become: \\(a_x = -\\frac{k}{m} v_x, \\quad a_y = -g - \\frac{k}{m} v_y\\)","title":"5. Air Resistance &amp; Improved Models"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visualization-with-air-resistance","text":"import numpy as np import matplotlib.pyplot as plt # Projectile parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) g = 9.81 # Gravitational acceleration (m/s^2) mass = 0.5 # Mass of the object (kg) drag_coefficient = 0.1 # Air resistance coefficient (kg/m) # Helper functions def trajectory_no_air_resistance(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient, dt=0.01): angle_rad = np.radians(angle) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, 0 x_positions, y_positions = [x], [y] while y >= 0: ax = -drag_coefficient * vx / mass ay = -g - (drag_coefficient * vy / mass) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_positions.append(x) y_positions.append(y) return x_positions, y_positions # Simulation time for the case without air resistance t_max = 2 * v0 * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, num=500) # Calculations x_no_air, y_no_air = trajectory_no_air_resistance(v0, angle, g, t) x_with_air, y_with_air = trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient) # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air, y_no_air, label=\"Without air resistance\", linestyle=\"--\") plt.plot(x_with_air, y_with_air, label=\"With air resistance\", linestyle=\"-\") plt.title(\"Projectile motion: comparison with and without air resistance\") plt.xlabel(\"Distance (m)\") plt.ylabel(\"Height (m)\") plt.legend() plt.grid() plt.show() ## Projectile Motion with and Without Air Resistance (with Bouncing)","title":"\ud83d\udccc Visualization with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-what-does-this-code-do","text":"This Python script simulates and visualizes projectile motion with and without air resistance, including bounces off the ground. The animation shows how air resistance affects the motion of a projectile compared to the idealized case with no drag. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters m = 1.0 # Mass [kg] g = 9.81 # Gravitational acceleration [m/s^2] k = 0.1 # Air resistance coefficient [kg/s] v0 = 20 # Initial velocity [m/s] theta = np.radians(45) # Initial angle [degrees -> radians] dt = 0.02 # Time step [s] T = 5 # Simulation time [s] elasticity = 0.7 # Coefficient of restitution # Function to calculate trajectory without air resistance def trajectory_no_drag(v0, theta, g, dt, T, elasticity): x, y = [0], [0] vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) t = 0 while t < T: x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt - 0.5 * g * dt**2 vy -= g * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Function to calculate trajectory with air resistance def trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity): vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = [0], [0] t = 0 while t < T: ax = - (k / m) * vx ay = -g - (k / m) * vy vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Compute trajectories x_no_drag, y_no_drag = trajectory_no_drag(v0, theta, g, dt, T, elasticity) x_drag, y_drag = trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity) # Initialize animation fig, ax = plt.subplots(figsize=(8, 5)) ax.set_xlim(0, max(max(x_no_drag), max(x_drag))) ax.set_ylim(0, max(max(y_no_drag), max(y_drag))) ax.set_xlabel(\"Distance [m]\") ax.set_ylabel(\"Height [m]\") ax.set_title(\"Projectile motion with and without air resistance (with bounces)\") ax.grid() point_no_drag, = ax.plot([], [], 'bo', label=\"Without air resistance\") point_drag, = ax.plot([], [], 'ro', label=\"With air resistance\") traj_no_drag, = ax.plot([], [], 'b--', alpha=0.5) traj_drag, = ax.plot([], [], 'r--', alpha=0.5) ax.legend() # Initialization function def init(): point_no_drag.set_data([], []) point_drag.set_data([], []) traj_no_drag.set_data([], []) traj_drag.set_data([], []) return point_no_drag, point_drag, traj_no_drag, traj_drag # Function to update the animation def update(frame): if frame < len(x_no_drag): point_no_drag.set_data([x_no_drag[frame]], [y_no_drag[frame]]) traj_no_drag.set_data(x_no_drag[:frame+1], y_no_drag[:frame+1]) if frame < len(x_drag): point_drag.set_data([x_drag[frame]], [y_drag[frame]]) traj_drag.set_data(x_drag[:frame+1], y_drag[:frame+1]) return point_no_drag, point_drag, traj_no_drag, traj_drag # Create animation frames = max(len(x_no_drag), len(x_drag)) ani = FuncAnimation(fig, update, frames=frames, init_func=init, blit=False, interval=20) # Display animation in Colab plt.close() HTML(ani.to_html5_video())","title":"1\ufe0f\u20e3 What Does This Code Do?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#link-to-the-simulation-above-on-google-colab","text":"https://colab.research.google.com/drive/1JAPKrMDEgJBFYaxuZgfnd50JqxAKGi-t?usp=sharing","title":"Link To The Simulation Above On Google Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#7-conclusion","text":"The range equation follows a clear mathematical pattern. Maximum range occurs at 45\u00b0 , confirmed analytically and numerically. Including air resistance shows a significant reduction in range . This study has applications in sports, engineering, and physics simulations.","title":"7. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#8-references-further-reading","text":"Resnick, R., & Halliday, D. (2004). Fundamentals of Physics . MIT OpenCourseWare: Classical Mechanics Lectures. NASA\u2019s trajectory analysis for spacecraft launches.","title":"8. References &amp; Further Reading"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum: Theoretical and Computational Analysis Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The equation governing the motion of a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0 = \\sqrt{g/L}\\) for a simple pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force. For small angles ( \\(\\theta \\approx \\sin \\theta\\) ), the equation simplifies to a linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a homogeneous part (damped oscillation) and a particular part (forced oscillation). When the driving frequency approaches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), resonance occurs, leading to large oscillations. 2. Analysis of Dynamics We analyze the system by varying: - Damping coefficient ( \\(\\gamma\\) ) - Driving force amplitude ( \\(A\\) ) - Driving frequency ( \\(\\omega\\) ) Numerical Solution Using Python We use the Runge-Kutta method to solve the system numerically and visualize its dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equations of motion def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions tspan = [0, 50] # Time span y0 = [0.2, 0] # Initial angle and angular velocity # Solve the ODE sol = solve_ivp(forced_damped_pendulum, tspan, y0, args=(gamma, omega0, A, omega), t_eval=np.linspace(0, 50, 1000)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Theta (Angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() 3. Practical Applications The forced damped pendulum model is relevant in: - Energy harvesting devices : Utilizing resonance for energy collection. - Suspension bridges : Understanding oscillatory instabilities. - Oscillating circuits : Analogous behavior in RLC circuits. 4. Phase Portrait and Poincar\u00e9 Section A phase portrait illustrates the evolution of \\((\\theta, \\omega_\\theta)\\) over time, revealing transitions to chaos. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Diferansiyel Denklemi def pendulum(t, state, q, \u03a9, F): \u03b8, \u03c9 = state d\u03b8dt = \u03c9 d\u03c9dt = -q * \u03c9 - np.sin(\u03b8) + F * np.cos(\u03a9 * t) return [d\u03b8dt, d\u03c9dt] # Parametreler q = 0.5 # S\u00f6n\u00fcm katsay\u0131s\u0131 \u03a9 = 2/3 # Zorlanma frekans\u0131 F = 1.2 # Zorlanma kuvveti # Ba\u015flang\u0131\u00e7 ko\u015fullar\u0131: [\u03b8(0), \u03c9(0)] theta_0 = 0.2 omega_0 = 0.0 # Zaman aral\u0131\u011f\u0131 t_span = (0, 50) # 0 ile 50 saniye aras\u0131nda \u00e7\u00f6z\u00fcmle t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1000 zaman noktas\u0131 # \u00c7\u00f6z\u00fcm\u00fc Bul sol = solve_ivp(pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(q, \u03a9, F)) # Faz Portresi \u00c7izimi plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label=\"Faz Uzay\u0131 (\u03b8 vs \u03c9)\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"A\u00e7\u0131sal H\u0131z (rad/s)\") plt.title(\"Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Faz Portresi\") plt.legend() plt.grid() plt.show() 5. Conclusion We explored the dynamics of a forced damped pendulum through theory and simulation. By varying parameters, we observed transitions from periodic motion to chaos. Future work could include: - Introducing nonlinear damping, - Exploring non-periodic driving forces. This study bridges theoretical physics with engineering applications, demonstrating the richness of nonlinear dynamical systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-theoretical-and-computational-analysis","text":"","title":"Forced Damped Pendulum: Theoretical and Computational Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The equation governing the motion of a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0 = \\sqrt{g/L}\\) for a simple pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force. For small angles ( \\(\\theta \\approx \\sin \\theta\\) ), the equation simplifies to a linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a homogeneous part (damped oscillation) and a particular part (forced oscillation). When the driving frequency approaches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), resonance occurs, leading to large oscillations.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"We analyze the system by varying: - Damping coefficient ( \\(\\gamma\\) ) - Driving force amplitude ( \\(A\\) ) - Driving frequency ( \\(\\omega\\) )","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-solution-using-python","text":"We use the Runge-Kutta method to solve the system numerically and visualize its dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equations of motion def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions tspan = [0, 50] # Time span y0 = [0.2, 0] # Initial angle and angular velocity # Solve the ODE sol = solve_ivp(forced_damped_pendulum, tspan, y0, args=(gamma, omega0, A, omega), t_eval=np.linspace(0, 50, 1000)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Theta (Angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Numerical Solution Using Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model is relevant in: - Energy harvesting devices : Utilizing resonance for energy collection. - Suspension bridges : Understanding oscillatory instabilities. - Oscillating circuits : Analogous behavior in RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-phase-portrait-and-poincare-section","text":"A phase portrait illustrates the evolution of \\((\\theta, \\omega_\\theta)\\) over time, revealing transitions to chaos. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Diferansiyel Denklemi def pendulum(t, state, q, \u03a9, F): \u03b8, \u03c9 = state d\u03b8dt = \u03c9 d\u03c9dt = -q * \u03c9 - np.sin(\u03b8) + F * np.cos(\u03a9 * t) return [d\u03b8dt, d\u03c9dt] # Parametreler q = 0.5 # S\u00f6n\u00fcm katsay\u0131s\u0131 \u03a9 = 2/3 # Zorlanma frekans\u0131 F = 1.2 # Zorlanma kuvveti # Ba\u015flang\u0131\u00e7 ko\u015fullar\u0131: [\u03b8(0), \u03c9(0)] theta_0 = 0.2 omega_0 = 0.0 # Zaman aral\u0131\u011f\u0131 t_span = (0, 50) # 0 ile 50 saniye aras\u0131nda \u00e7\u00f6z\u00fcmle t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1000 zaman noktas\u0131 # \u00c7\u00f6z\u00fcm\u00fc Bul sol = solve_ivp(pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(q, \u03a9, F)) # Faz Portresi \u00c7izimi plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label=\"Faz Uzay\u0131 (\u03b8 vs \u03c9)\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"A\u00e7\u0131sal H\u0131z (rad/s)\") plt.title(\"Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Faz Portresi\") plt.legend() plt.grid() plt.show()","title":"4. Phase Portrait and Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-conclusion","text":"We explored the dynamics of a forced damped pendulum through theory and simulation. By varying parameters, we observed transitions from periodic motion to chaos. Future work could include: - Introducing nonlinear damping, - Exploring non-periodic driving forces. This study bridges theoretical physics with engineering applications, demonstrating the richness of nonlinear dynamical systems.","title":"5. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler's Third Law states that the square of the orbital period \\( \\(T\\) \\) of a planet is proportional to the cube of the semi-major axis (orbital radius) \\( \\(r\\) \\) of its orbit. Mathematically: \\[T^2 \\propto r^3\\] This fundamental relationship allows us to: - Predict planetary motions - Calculate planetary masses and distances - Understand gravitational interactions in celestial mechanics 1. Derivation of the Relationship To derive Kepler's Third Law, we start with Newton\u2019s Law of Gravitation: \\[F = \\frac{GMm}{r^2}\\] where: - \\( \\(G\\) \\) is the gravitational constant, - \\( \\(M\\) \\) is the mass of the central body, - \\( \\(m\\) \\) is the mass of the orbiting object, - \\( \\(r\\) \\) is the orbital radius. For circular orbits, the centripetal force is provided by gravity: \\[F = \\frac{m v^2}{r}\\] Equating gravitational force to centripetal force: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Canceling \\( \\(m\\) \\) and rearranging: \\[v^2 = \\frac{GM}{r}\\] The orbital period is given by: \\[T = \\frac{2\\pi r}{v}\\] Substituting \\( \\(v\\) \\) : \\[T = \\frac{2\\pi r}{\\sqrt{GM/r}}\\] Squaring both sides: \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] Thus, we arrive at Kepler's Third Law: \\[T^2 \\propto r^3\\] 2. Implications for Astronomy Kepler's Third Law is crucial in: - Determining planetary masses and distances using observed orbital periods - Satellite and spacecraft navigation - Studying exoplanetary systems Real-World Examples Moon's Orbit Around Earth : Period: \\( \\(T_{moon} \\approx 27.3\\) \\) days Radius: \\( \\(r_{moon} \\approx 3.84 \\times 10^5\\) \\) km Planets in the Solar System : For Earth: \\( \\(T = 1\\) \\) year, \\( \\(r = 1 AU\\) \\) For Mars: \\( \\(T = 1.88\\) \\) years, \\( \\(r = 1.52 AU\\) \\) (follows \\( \\(T^2 \\propto r^3\\) \\) ) 3. Computational Simulation of Circular Orbits Below is a Python script that simulates circular orbits and verifies Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # 1 Astronomical Unit in meters # Function to compute orbital period def orbital_period(r, M): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital radii in AU radii_AU = np.linspace(0.1, 5, 10) radii_m = radii_AU * AU # Compute periods periods = orbital_period(radii_m, M_sun) / (60 * 60 * 24 * 365) # Convert to years # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii_m**3, periods**2, 'bo-', label='$T^2$ vs $r^3$') plt.xlabel('$r^3$ (m^3)') plt.ylabel('$T^2$ (years^2)') plt.title('Verification of Kepler\\'s Third Law') plt.legend() plt.grid() plt.show() 4. Extension to Elliptical Orbits Kepler's Third Law also applies to elliptical orbits , where: \\[r$$ is replaced by the **semi-major axis** $$a\\] The relationship still holds: \\( \\(T^2 \\propto a^3\\) \\) This generalization allows for: - Understanding cometary orbits (e.g., Halley's Comet) - Studying binary star systems - Determining galactic dynamics Conclusion Kepler's Third Law provides a direct link between orbital periods and radii. It helps predict planetary motions and system dynamics . Computational models confirm the theoretical relationship. The law extends to elliptical orbits and cosmic scales . References Kepler, J. Astronomia Nova (1609) Newton, I. Principia Mathematica (1687) NASA Planetary Data","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law states that the square of the orbital period \\( \\(T\\) \\) of a planet is proportional to the cube of the semi-major axis (orbital radius) \\( \\(r\\) \\) of its orbit. Mathematically: \\[T^2 \\propto r^3\\] This fundamental relationship allows us to: - Predict planetary motions - Calculate planetary masses and distances - Understand gravitational interactions in celestial mechanics","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-the-relationship","text":"To derive Kepler's Third Law, we start with Newton\u2019s Law of Gravitation: \\[F = \\frac{GMm}{r^2}\\] where: - \\( \\(G\\) \\) is the gravitational constant, - \\( \\(M\\) \\) is the mass of the central body, - \\( \\(m\\) \\) is the mass of the orbiting object, - \\( \\(r\\) \\) is the orbital radius. For circular orbits, the centripetal force is provided by gravity: \\[F = \\frac{m v^2}{r}\\] Equating gravitational force to centripetal force: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Canceling \\( \\(m\\) \\) and rearranging: \\[v^2 = \\frac{GM}{r}\\] The orbital period is given by: \\[T = \\frac{2\\pi r}{v}\\] Substituting \\( \\(v\\) \\) : \\[T = \\frac{2\\pi r}{\\sqrt{GM/r}}\\] Squaring both sides: \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] Thus, we arrive at Kepler's Third Law: \\[T^2 \\propto r^3\\]","title":"1. Derivation of the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler's Third Law is crucial in: - Determining planetary masses and distances using observed orbital periods - Satellite and spacecraft navigation - Studying exoplanetary systems","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"Moon's Orbit Around Earth : Period: \\( \\(T_{moon} \\approx 27.3\\) \\) days Radius: \\( \\(r_{moon} \\approx 3.84 \\times 10^5\\) \\) km Planets in the Solar System : For Earth: \\( \\(T = 1\\) \\) year, \\( \\(r = 1 AU\\) \\) For Mars: \\( \\(T = 1.88\\) \\) years, \\( \\(r = 1.52 AU\\) \\) (follows \\( \\(T^2 \\propto r^3\\) \\) )","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-computational-simulation-of-circular-orbits","text":"Below is a Python script that simulates circular orbits and verifies Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # 1 Astronomical Unit in meters # Function to compute orbital period def orbital_period(r, M): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital radii in AU radii_AU = np.linspace(0.1, 5, 10) radii_m = radii_AU * AU # Compute periods periods = orbital_period(radii_m, M_sun) / (60 * 60 * 24 * 365) # Convert to years # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii_m**3, periods**2, 'bo-', label='$T^2$ vs $r^3$') plt.xlabel('$r^3$ (m^3)') plt.ylabel('$T^2$ (years^2)') plt.title('Verification of Kepler\\'s Third Law') plt.legend() plt.grid() plt.show()","title":"3. Computational Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-extension-to-elliptical-orbits","text":"Kepler's Third Law also applies to elliptical orbits , where: \\[r$$ is replaced by the **semi-major axis** $$a\\] The relationship still holds: \\( \\(T^2 \\propto a^3\\) \\) This generalization allows for: - Understanding cometary orbits (e.g., Halley's Comet) - Studying binary star systems - Determining galactic dynamics","title":"4. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law provides a direct link between orbital periods and radii. It helps predict planetary motions and system dynamics . Computational models confirm the theoretical relationship. The law extends to elliptical orbits and cosmic scales .","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","text":"Kepler, J. Astronomia Nova (1609) Newton, I. Principia Mathematica (1687) NASA Planetary Data","title":"References"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. 1. Definitions of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) The minimum velocity required for a body to stay in a stable circular orbit around a celestial body. Derived using centripetal force balance with gravitational force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The minimum velocity required to escape a celestial body\u2019s gravitational field. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity (Solar System Escape Velocity) The minimum velocity required to escape both the planet\u2019s gravity and the Sun\u2019s gravitational influence. Derived from combining the escape velocity of the planet and the escape velocity from the Sun: $$ v_3 = \\sqrt{v_{\\text{escape, planet}}^2 + v_{\\text{escape, sun}}^2} $$ 2. Mathematical Derivations and Parameters Affecting These Velocities Gravitational constant (G) : \\( 6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) Mass of celestial body (M) Radius of celestial body (R) For third cosmic velocity, Sun's mass and distance are also considered. 3. Python Code to Calculate and Visualize Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in m) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Compute velocities velocities = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots(figsize=(8, 6)) x_labels = list(velocities.keys()) v1_vals = [velocities[body][0] for body in x_labels] v2_vals = [velocities[body][1] for body in x_labels] ax.bar(x_labels, v1_vals, label=\"First Cosmic Velocity (km/s)\", color=\"blue\") ax.bar(x_labels, v2_vals, label=\"Second Cosmic Velocity (km/s)\", color=\"red\", alpha=0.7) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"First and Second Cosmic Velocities for Celestial Bodies\") ax.legend() plt.show() 4. Discussion on Space Exploration Satellites : Launched at first cosmic velocity to remain in orbit. Interplanetary Missions : Rockets must reach at least second cosmic velocity to escape Earth's gravity. Interstellar Travel : Requires surpassing the third cosmic velocity to leave the Sun\u2019s gravitational influence.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-of-cosmic-velocities","text":"","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The minimum velocity required for a body to stay in a stable circular orbit around a celestial body. Derived using centripetal force balance with gravitational force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The minimum velocity required to escape a celestial body\u2019s gravitational field. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-solar-system-escape-velocity","text":"The minimum velocity required to escape both the planet\u2019s gravity and the Sun\u2019s gravitational influence. Derived from combining the escape velocity of the planet and the escape velocity from the Sun: $$ v_3 = \\sqrt{v_{\\text{escape, planet}}^2 + v_{\\text{escape, sun}}^2} $$","title":"Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations-and-parameters-affecting-these-velocities","text":"Gravitational constant (G) : \\( 6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) Mass of celestial body (M) Radius of celestial body (R) For third cosmic velocity, Sun's mass and distance are also considered.","title":"2. Mathematical Derivations and Parameters Affecting These Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-to-calculate-and-visualize-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in m) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Compute velocities velocities = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots(figsize=(8, 6)) x_labels = list(velocities.keys()) v1_vals = [velocities[body][0] for body in x_labels] v2_vals = [velocities[body][1] for body in x_labels] ax.bar(x_labels, v1_vals, label=\"First Cosmic Velocity (km/s)\", color=\"blue\") ax.bar(x_labels, v2_vals, label=\"Second Cosmic Velocity (km/s)\", color=\"red\", alpha=0.7) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"First and Second Cosmic Velocities for Celestial Bodies\") ax.legend() plt.show()","title":"3. Python Code to Calculate and Visualize Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-discussion-on-space-exploration","text":"Satellites : Launched at first cosmic velocity to remain in orbit. Interplanetary Missions : Rockets must reach at least second cosmic velocity to escape Earth's gravity. Interstellar Travel : Requires surpassing the third cosmic velocity to leave the Sun\u2019s gravitational influence.","title":"4. Discussion on Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Before diving into theory, explore how real spacecraft move using NASA\u2019s official 3D simulation platform: \ud83c\udf10 NASA Eyes on the Solar System Real-time orbits, mission tracking, and gravity interactions! \ud83c\udfaf Motivation When a payload is released from a moving rocket near Earth, it may follow various trajectories depending on its initial velocity and position. This problem blends orbital mechanics and numerical simulations \u2014 essential for tasks like satellite deployment, reentry, and interplanetary missions. \ud83c\udf0d Governing Physics To better understand gravitational attraction and orbital motion, you can explore this interactive simulation: \ud83c\udf10 PhET: Gravity and Orbits Visualize how mass, distance, and velocity affect planetary orbits and satellite motion in real time! Newton's Law of Gravitation The gravitational force on the payload is: \\[ \\vec{F} = - \\frac{GMm}{r^2} \\hat{r} \\] \\( G = 6.674 \\times 10^{-11} \\, \\text{m}^3/\\text{kg s}^2 \\) \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) (Earth's mass) \\( m \\) : Payload mass (cancels out in acceleration) \\( r \\) : Distance from Earth's center Using Newton's Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = - \\frac{GM}{r^2} \\hat{r} \\] \ud83c\udf0c Orbital Energy and Trajectories Total specific mechanical energy of the payload: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\( \\epsilon < 0 \\) : Elliptical orbit (bound) \\( \\epsilon = 0 \\) : Parabolic trajectory (escape) \\( \\epsilon > 0 \\) : Hyperbolic trajectory (escape) Escape velocity at distance \\( r \\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Escape velocity decreases with altitude since gravitational pull weakens. It is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Below is a plot showing how escape velocity changes with altitude: \ud83e\uddee Numerical Simulation (Euler Method) We simulate the payload motion using small time steps. Assumptions: 2D motion (x, y) Only gravitational force from Earth Earth is a point mass at the origin \ud83d\udce6 Python Implementation import numpy as np Constants G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # Earth mass [kg] R_earth = 6.371e6 # Earth radius [m] Initial conditions altitude = 300e3 r0 = R_earth + altitude v0 = 7500 # initial speed [m/s] theta = np.radians(0) x = [r0] y = [0] vx = [0] vy = [v0] dt = 1 # time step [s] t_max = 8000 N = int(t_max / dt) print(\"Time (s)\\tX (km)\\tY (km)\\tSpeed (km/s)\\tDistance from Earth Center (km)\") for i in range(N): r = np.sqrt(x[-1] 2 + y[-1] 2) ax = -G * M * x[-1] / r 3 ay = -G * M * y[-1] / r 3 vx_new = vx[-1] + ax * dt vy_new = vy[-1] + ay * dt x_new = x[-1] + vx_new * dt y_new = y[-1] + vy_new * dt distance_km = np.sqrt(x_new**2 + y_new**2) / 1000 speed_kms = np.sqrt(vx_new**2 + vy_new**2) / 1000 print(f\"{i*dt:6d}\\t{x_new/1000:.2f}\\t{y_new/1000:.2f}\\t{speed_kms:.2f}\\t{distance_km:.2f}\") if distance_km * 1000 <= R_earth: print(\"\\n>> Payload has re-entered the Earth at t =\", i*dt, \"seconds\") break x.append(x_new) y.append(y_new) vx.append(vx_new) vy.append(vy_new) \ud83d\udd0d Explore Further: Beyond Earth While this project focuses on payloads near Earth, it's also valuable to understand more complex gravitational dynamics. \ud83c\udfa5 SkyMarvels\u2122 \u2013 Solar System Barycenter How the Sun moves due to gravitational pulls from the planets \u2014 visualized with Celestia. Barycenters explain why the Sun itself moves slightly \u2014 important for understanding motion in multi-body systems.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"Before diving into theory, explore how real spacecraft move using NASA\u2019s official 3D simulation platform: \ud83c\udf10 NASA Eyes on the Solar System Real-time orbits, mission tracking, and gravity interactions!","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, it may follow various trajectories depending on its initial velocity and position. This problem blends orbital mechanics and numerical simulations \u2014 essential for tasks like satellite deployment, reentry, and interplanetary missions.","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-physics","text":"To better understand gravitational attraction and orbital motion, you can explore this interactive simulation: \ud83c\udf10 PhET: Gravity and Orbits Visualize how mass, distance, and velocity affect planetary orbits and satellite motion in real time!","title":"\ud83c\udf0d Governing Physics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-gravitation","text":"The gravitational force on the payload is: \\[ \\vec{F} = - \\frac{GMm}{r^2} \\hat{r} \\] \\( G = 6.674 \\times 10^{-11} \\, \\text{m}^3/\\text{kg s}^2 \\) \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) (Earth's mass) \\( m \\) : Payload mass (cancels out in acceleration) \\( r \\) : Distance from Earth's center Using Newton's Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = - \\frac{GM}{r^2} \\hat{r} \\]","title":"Newton's Law of Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-energy-and-trajectories","text":"Total specific mechanical energy of the payload: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\( \\epsilon < 0 \\) : Elliptical orbit (bound) \\( \\epsilon = 0 \\) : Parabolic trajectory (escape) \\( \\epsilon > 0 \\) : Hyperbolic trajectory (escape) Escape velocity at distance \\( r \\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Escape velocity decreases with altitude since gravitational pull weakens. It is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Below is a plot showing how escape velocity changes with altitude:","title":"\ud83c\udf0c Orbital Energy and Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-euler-method","text":"We simulate the payload motion using small time steps.","title":"\ud83e\uddee Numerical Simulation (Euler Method)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#assumptions","text":"2D motion (x, y) Only gravitational force from Earth Earth is a point mass at the origin","title":"Assumptions:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"import numpy as np","title":"\ud83d\udce6 Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#constants","text":"G = 6.67430e-11 # gravitational constant [m^3/kg/s^2] M = 5.972e24 # Earth mass [kg] R_earth = 6.371e6 # Earth radius [m]","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_3/#initial-conditions","text":"altitude = 300e3 r0 = R_earth + altitude v0 = 7500 # initial speed [m/s] theta = np.radians(0) x = [r0] y = [0] vx = [0] vy = [v0] dt = 1 # time step [s] t_max = 8000 N = int(t_max / dt) print(\"Time (s)\\tX (km)\\tY (km)\\tSpeed (km/s)\\tDistance from Earth Center (km)\") for i in range(N): r = np.sqrt(x[-1] 2 + y[-1] 2) ax = -G * M * x[-1] / r 3 ay = -G * M * y[-1] / r 3 vx_new = vx[-1] + ax * dt vy_new = vy[-1] + ay * dt x_new = x[-1] + vx_new * dt y_new = y[-1] + vy_new * dt distance_km = np.sqrt(x_new**2 + y_new**2) / 1000 speed_kms = np.sqrt(vx_new**2 + vy_new**2) / 1000 print(f\"{i*dt:6d}\\t{x_new/1000:.2f}\\t{y_new/1000:.2f}\\t{speed_kms:.2f}\\t{distance_km:.2f}\") if distance_km * 1000 <= R_earth: print(\"\\n>> Payload has re-entered the Earth at t =\", i*dt, \"seconds\") break x.append(x_new) y.append(y_new) vx.append(vx_new) vy.append(vy_new)","title":"Initial conditions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explore-further-beyond-earth","text":"While this project focuses on payloads near Earth, it's also valuable to understand more complex gravitational dynamics. \ud83c\udfa5 SkyMarvels\u2122 \u2013 Solar System Barycenter How the Sun moves due to gravitational pulls from the planets \u2014 visualized with Celestia. Barycenters explain why the Sun itself moves slightly \u2014 important for understanding motion in multi-body systems.","title":"\ud83d\udd0d Explore Further: Beyond Earth"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}