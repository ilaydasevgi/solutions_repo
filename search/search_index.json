{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection 1. Motivation Projectile motion, while seemingly simple, provides a rich foundation for understanding fundamental physics principles. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. However, beneath this simplicity lies a complex framework involving both linear and quadratic relationships. This topic is particularly compelling due to the number of free parameters involved, such as: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch height \\(h\\) These parameters give rise to a diverse set of solutions that describe real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket. 2. Theoretical Foundation To analyze projectile motion, we derive the governing equations from fundamental principles, primarily Newton's second law of motion. 2.1. Equations of Motion Projectile motion is governed by Newton\u2019s Second Law: \\(F = m \\cdot a\\) For a projectile, forces acting on the object include: 1. Gravity ( \\(mg\\) ) in the vertical direction. 2. No horizontal forces (ignoring air resistance initially). Thus, the acceleration components are: \\(a_x = 0, \\quad a_y = -g\\) Integrating these equations, we obtain the velocity components: \\(v_x = v_0 \\cos(\\theta), \\quad v_y = v_0 \\sin(\\theta) - g t\\) Further integration gives the position equations: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) The horizontal and vertical motion of a projectile are governed by kinematic equations: Horizontal motion (constant velocity): \\[x(t) = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated motion due to gravity): \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\] where: \\(x(t)\\) and \\(y(t)\\) are the projectile's position at time \\(t\\) . \\(v_0\\) is the initial velocity. \\(\\theta\\) is the launch angle. \\(g\\) is the gravitational acceleration (typically 9.81 m/s\u00b2 on Earth). These fundamental equations describe projectile motion and will now be used to analyze range and time of flight. 2.2. Time of Flight The total time the projectile spends in the air can be determined by setting \\(y(t) = 0\\) : \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\) 2.3. Range Equation The range \\(R\\) is the total horizontal distance traveled before the projectile lands. Using \\(t_f\\) in the horizontal motion equation: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the trigonometric identity \\(2\\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we obtain: \\(R(\\theta) = \\frac{v_0^2}{g} \\sin(2\\theta)\\) 2.4. Maximum Range The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, which happens at \\(\\theta = 45^\\circ\\) : \\(R_{max} = \\frac{v_0^2}{g}\\) 3. Analysis of the Range 3.1. Dependence on Angle The range follows a symmetrical pattern around \\(\\theta = 45^\\circ\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) result in the same range. 3.2. Effect of Initial Velocity Higher \\(v_0\\) leads to a longer range, proportional to \\(v_0^2\\) . 3.3. Effect of Gravity A larger \\(g\\) (such as on Jupiter) reduces range, while a smaller \\(g\\) (such as on the Moon) increases it. \ud83d\udccc Improved Range Plot with Annotations import numpy as np import matplotlib.pyplot as plt # Define parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s^2) theta = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees # Compute range R = (v0**2 * np.sin(np.deg2rad(2 * theta))) / g # Plot the range vs. angle plt.figure(figsize=(10, 6)) plt.plot(theta, R, label='Range (R)', color='blue') # Mark the maximum range at 45\u00b0 plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.text(46, max(R)-2, \"Maximum Range\", color='red') plt.xlabel('Projection Angle (\u03b8) [Degrees]') plt.ylabel('Range (R) [m]') plt.title('Projectile Range as a Function of Launch Angle') plt.grid(True) plt.legend() plt.show() 4. Implementation: Python Visualization We implement a computational tool to visualize the range as a function of the angle. \ud83d\ude80 Projectile Motion Simulation This simulation demonstrates the parabolic trajectory of a projectile launched at a given angle and velocity. Users can adjust the launch angle and initial speed , allowing them to observe how different conditions affect projectile motion. \ud83d\udccc How It Works? The user selects a launch angle (0\u00b0 - 90\u00b0) and initial velocity (5 - 50 m/s) . Pressing the \"Start Simulation\" button runs the animation based on the selected values. A moving particle (blue dot) follows a curved trajectory due to gravity . The graph dynamically updates to show the horizontal and vertical motion. \ud83d\udda5 Use Cases \u2705 Understanding projectile motion in physics courses. \u2705 Basic modeling for engineering and ballistic calculations. \u2705 Trajectory analysis for real-world problems. \ud83d\udd17 Run the Simulation on Google Colab: Link text 5. Air Resistance & Improved Models In reality, projectiles experience air resistance proportional to velocity: \\(F_{drag} = - k v^2\\) The equations of motion now become: \\(a_x = -\\frac{k}{m} v_x, \\quad a_y = -g - \\frac{k}{m} v_y\\) \ud83d\udccc Visualization with Air Resistance import numpy as np import matplotlib.pyplot as plt # Projectile parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) g = 9.81 # Gravitational acceleration (m/s^2) mass = 0.5 # Mass of the object (kg) drag_coefficient = 0.1 # Air resistance coefficient (kg/m) # Helper functions def trajectory_no_air_resistance(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient, dt=0.01): angle_rad = np.radians(angle) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, 0 x_positions, y_positions = [x], [y] while y >= 0: ax = -drag_coefficient * vx / mass ay = -g - (drag_coefficient * vy / mass) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_positions.append(x) y_positions.append(y) return x_positions, y_positions # Simulation time for the case without air resistance t_max = 2 * v0 * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, num=500) # Calculations x_no_air, y_no_air = trajectory_no_air_resistance(v0, angle, g, t) x_with_air, y_with_air = trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient) # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air, y_no_air, label=\"Without air resistance\", linestyle=\"--\") plt.plot(x_with_air, y_with_air, label=\"With air resistance\", linestyle=\"-\") plt.title(\"Projectile motion: comparison with and without air resistance\") plt.xlabel(\"Distance (m)\") plt.ylabel(\"Height (m)\") plt.legend() plt.grid() plt.show() ## Projectile Motion with and Without Air Resistance (with Bouncing) 1\ufe0f\u20e3 What Does This Code Do? This Python script simulates and visualizes projectile motion with and without air resistance, including bounces off the ground. The animation shows how air resistance affects the motion of a projectile compared to the idealized case with no drag. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters m = 1.0 # Mass [kg] g = 9.81 # Gravitational acceleration [m/s^2] k = 0.1 # Air resistance coefficient [kg/s] v0 = 20 # Initial velocity [m/s] theta = np.radians(45) # Initial angle [degrees -> radians] dt = 0.02 # Time step [s] T = 5 # Simulation time [s] elasticity = 0.7 # Coefficient of restitution # Function to calculate trajectory without air resistance def trajectory_no_drag(v0, theta, g, dt, T, elasticity): x, y = [0], [0] vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) t = 0 while t < T: x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt - 0.5 * g * dt**2 vy -= g * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Function to calculate trajectory with air resistance def trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity): vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = [0], [0] t = 0 while t < T: ax = - (k / m) * vx ay = -g - (k / m) * vy vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Compute trajectories x_no_drag, y_no_drag = trajectory_no_drag(v0, theta, g, dt, T, elasticity) x_drag, y_drag = trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity) # Initialize animation fig, ax = plt.subplots(figsize=(8, 5)) ax.set_xlim(0, max(max(x_no_drag), max(x_drag))) ax.set_ylim(0, max(max(y_no_drag), max(y_drag))) ax.set_xlabel(\"Distance [m]\") ax.set_ylabel(\"Height [m]\") ax.set_title(\"Projectile motion with and without air resistance (with bounces)\") ax.grid() point_no_drag, = ax.plot([], [], 'bo', label=\"Without air resistance\") point_drag, = ax.plot([], [], 'ro', label=\"With air resistance\") traj_no_drag, = ax.plot([], [], 'b--', alpha=0.5) traj_drag, = ax.plot([], [], 'r--', alpha=0.5) ax.legend() # Initialization function def init(): point_no_drag.set_data([], []) point_drag.set_data([], []) traj_no_drag.set_data([], []) traj_drag.set_data([], []) return point_no_drag, point_drag, traj_no_drag, traj_drag # Function to update the animation def update(frame): if frame < len(x_no_drag): point_no_drag.set_data([x_no_drag[frame]], [y_no_drag[frame]]) traj_no_drag.set_data(x_no_drag[:frame+1], y_no_drag[:frame+1]) if frame < len(x_drag): point_drag.set_data([x_drag[frame]], [y_drag[frame]]) traj_drag.set_data(x_drag[:frame+1], y_drag[:frame+1]) return point_no_drag, point_drag, traj_no_drag, traj_drag # Create animation frames = max(len(x_no_drag), len(x_drag)) ani = FuncAnimation(fig, update, frames=frames, init_func=init, blit=False, interval=20) # Display animation in Colab plt.close() HTML(ani.to_html5_video()) Link To The Simulation Above On Google Colab https://colab.research.google.com/drive/1JAPKrMDEgJBFYaxuZgfnd50JqxAKGi-t?usp=sharing 7. Conclusion The range equation follows a clear mathematical pattern. Maximum range occurs at 45\u00b0 , confirmed analytically and numerically. Including air resistance shows a significant reduction in range . This study has applications in sports, engineering, and physics simulations. 8. References & Further Reading Resnick, R., & Halliday, D. (2004). Fundamentals of Physics . MIT OpenCourseWare: Classical Mechanics Lectures. NASA\u2019s trajectory analysis for spacecraft launches.","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-motivation","text":"Projectile motion, while seemingly simple, provides a rich foundation for understanding fundamental physics principles. The problem is straightforward: analyze how the range of a projectile depends on its angle of projection. However, beneath this simplicity lies a complex framework involving both linear and quadratic relationships. This topic is particularly compelling due to the number of free parameters involved, such as: Initial velocity \\(v_0\\) Gravitational acceleration \\(g\\) Launch height \\(h\\) These parameters give rise to a diverse set of solutions that describe real-world phenomena, from the arc of a soccer ball to the trajectory of a rocket.","title":"1. Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-theoretical-foundation","text":"To analyze projectile motion, we derive the governing equations from fundamental principles, primarily Newton's second law of motion.","title":"2. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#21-equations-of-motion","text":"Projectile motion is governed by Newton\u2019s Second Law: \\(F = m \\cdot a\\) For a projectile, forces acting on the object include: 1. Gravity ( \\(mg\\) ) in the vertical direction. 2. No horizontal forces (ignoring air resistance initially). Thus, the acceleration components are: \\(a_x = 0, \\quad a_y = -g\\) Integrating these equations, we obtain the velocity components: \\(v_x = v_0 \\cos(\\theta), \\quad v_y = v_0 \\sin(\\theta) - g t\\) Further integration gives the position equations: \\(x(t) = v_0 \\cos(\\theta) \\cdot t\\) \\(y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2\\) The horizontal and vertical motion of a projectile are governed by kinematic equations: Horizontal motion (constant velocity): \\[x(t) = v_0 \\cos(\\theta) t\\] Vertical motion (accelerated motion due to gravity): \\[y(t) = v_0 \\sin(\\theta) t - \\frac{1}{2} g t^2\\] where: \\(x(t)\\) and \\(y(t)\\) are the projectile's position at time \\(t\\) . \\(v_0\\) is the initial velocity. \\(\\theta\\) is the launch angle. \\(g\\) is the gravitational acceleration (typically 9.81 m/s\u00b2 on Earth). These fundamental equations describe projectile motion and will now be used to analyze range and time of flight.","title":"2.1. Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#22-time-of-flight","text":"The total time the projectile spends in the air can be determined by setting \\(y(t) = 0\\) : \\(t_f = \\frac{2 v_0 \\sin(\\theta)}{g}\\)","title":"2.2. Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#23-range-equation","text":"The range \\(R\\) is the total horizontal distance traveled before the projectile lands. Using \\(t_f\\) in the horizontal motion equation: \\(R = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g}\\) Using the trigonometric identity \\(2\\sin(\\theta) \\cos(\\theta) = \\sin(2\\theta)\\) , we obtain: \\(R(\\theta) = \\frac{v_0^2}{g} \\sin(2\\theta)\\)","title":"2.3. Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#24-maximum-range","text":"The maximum range occurs when \\(\\sin(2\\theta)\\) is maximized, which happens at \\(\\theta = 45^\\circ\\) : \\(R_{max} = \\frac{v_0^2}{g}\\)","title":"2.4. Maximum Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-analysis-of-the-range","text":"","title":"3. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#31-dependence-on-angle","text":"The range follows a symmetrical pattern around \\(\\theta = 45^\\circ\\) . Angles \\(\\theta\\) and \\(90^\\circ - \\theta\\) result in the same range.","title":"3.1. Dependence on Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#32-effect-of-initial-velocity","text":"Higher \\(v_0\\) leads to a longer range, proportional to \\(v_0^2\\) .","title":"3.2. Effect of Initial Velocity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#33-effect-of-gravity","text":"A larger \\(g\\) (such as on Jupiter) reduces range, while a smaller \\(g\\) (such as on the Moon) increases it.","title":"3.3. Effect of Gravity"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#improved-range-plot-with-annotations","text":"import numpy as np import matplotlib.pyplot as plt # Define parameters v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s^2) theta = np.linspace(0, 90, 100) # Angle range from 0 to 90 degrees # Compute range R = (v0**2 * np.sin(np.deg2rad(2 * theta))) / g # Plot the range vs. angle plt.figure(figsize=(10, 6)) plt.plot(theta, R, label='Range (R)', color='blue') # Mark the maximum range at 45\u00b0 plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.text(46, max(R)-2, \"Maximum Range\", color='red') plt.xlabel('Projection Angle (\u03b8) [Degrees]') plt.ylabel('Range (R) [m]') plt.title('Projectile Range as a Function of Launch Angle') plt.grid(True) plt.legend() plt.show()","title":"\ud83d\udccc Improved Range Plot with Annotations"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-visualization","text":"We implement a computational tool to visualize the range as a function of the angle.","title":"4. Implementation: Python Visualization"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#projectile-motion-simulation","text":"This simulation demonstrates the parabolic trajectory of a projectile launched at a given angle and velocity. Users can adjust the launch angle and initial speed , allowing them to observe how different conditions affect projectile motion.","title":"\ud83d\ude80 Projectile Motion Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#how-it-works","text":"The user selects a launch angle (0\u00b0 - 90\u00b0) and initial velocity (5 - 50 m/s) . Pressing the \"Start Simulation\" button runs the animation based on the selected values. A moving particle (blue dot) follows a curved trajectory due to gravity . The graph dynamically updates to show the horizontal and vertical motion.","title":"\ud83d\udccc How It Works?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#use-cases","text":"\u2705 Understanding projectile motion in physics courses. \u2705 Basic modeling for engineering and ballistic calculations. \u2705 Trajectory analysis for real-world problems. \ud83d\udd17 Run the Simulation on Google Colab: Link text","title":"\ud83d\udda5 Use Cases"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-air-resistance-improved-models","text":"In reality, projectiles experience air resistance proportional to velocity: \\(F_{drag} = - k v^2\\) The equations of motion now become: \\(a_x = -\\frac{k}{m} v_x, \\quad a_y = -g - \\frac{k}{m} v_y\\)","title":"5. Air Resistance &amp; Improved Models"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#visualization-with-air-resistance","text":"import numpy as np import matplotlib.pyplot as plt # Projectile parameters v0 = 50 # Initial velocity (m/s) angle = 45 # Launch angle (degrees) g = 9.81 # Gravitational acceleration (m/s^2) mass = 0.5 # Mass of the object (kg) drag_coefficient = 0.1 # Air resistance coefficient (kg/m) # Helper functions def trajectory_no_air_resistance(v0, angle, g, t): angle_rad = np.radians(angle) x = v0 * np.cos(angle_rad) * t y = v0 * np.sin(angle_rad) * t - 0.5 * g * t**2 return x, y def trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient, dt=0.01): angle_rad = np.radians(angle) vx = v0 * np.cos(angle_rad) vy = v0 * np.sin(angle_rad) x, y = 0, 0 x_positions, y_positions = [x], [y] while y >= 0: ax = -drag_coefficient * vx / mass ay = -g - (drag_coefficient * vy / mass) vx += ax * dt vy += ay * dt x += vx * dt y += vy * dt x_positions.append(x) y_positions.append(y) return x_positions, y_positions # Simulation time for the case without air resistance t_max = 2 * v0 * np.sin(np.radians(angle)) / g t = np.linspace(0, t_max, num=500) # Calculations x_no_air, y_no_air = trajectory_no_air_resistance(v0, angle, g, t) x_with_air, y_with_air = trajectory_with_air_resistance(v0, angle, g, mass, drag_coefficient) # Plot plt.figure(figsize=(10, 6)) plt.plot(x_no_air, y_no_air, label=\"Without air resistance\", linestyle=\"--\") plt.plot(x_with_air, y_with_air, label=\"With air resistance\", linestyle=\"-\") plt.title(\"Projectile motion: comparison with and without air resistance\") plt.xlabel(\"Distance (m)\") plt.ylabel(\"Height (m)\") plt.legend() plt.grid() plt.show() ## Projectile Motion with and Without Air Resistance (with Bouncing)","title":"\ud83d\udccc Visualization with Air Resistance"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-what-does-this-code-do","text":"This Python script simulates and visualizes projectile motion with and without air resistance, including bounces off the ground. The animation shows how air resistance affects the motion of a projectile compared to the idealized case with no drag. import numpy as np import matplotlib.pyplot as plt from matplotlib.animation import FuncAnimation from IPython.display import HTML # Parameters m = 1.0 # Mass [kg] g = 9.81 # Gravitational acceleration [m/s^2] k = 0.1 # Air resistance coefficient [kg/s] v0 = 20 # Initial velocity [m/s] theta = np.radians(45) # Initial angle [degrees -> radians] dt = 0.02 # Time step [s] T = 5 # Simulation time [s] elasticity = 0.7 # Coefficient of restitution # Function to calculate trajectory without air resistance def trajectory_no_drag(v0, theta, g, dt, T, elasticity): x, y = [0], [0] vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) t = 0 while t < T: x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt - 0.5 * g * dt**2 vy -= g * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Function to calculate trajectory with air resistance def trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity): vx, vy = v0 * np.cos(theta), v0 * np.sin(theta) x, y = [0], [0] t = 0 while t < T: ax = - (k / m) * vx ay = -g - (k / m) * vy vx += ax * dt vy += ay * dt x.append(x[-1] + vx * dt) y_new = y[-1] + vy * dt if y_new < 0: # Bounce off the ground vy = -vy * elasticity y_new = 0 y.append(y_new) t += dt return x, y # Compute trajectories x_no_drag, y_no_drag = trajectory_no_drag(v0, theta, g, dt, T, elasticity) x_drag, y_drag = trajectory_with_drag(v0, theta, g, k, m, dt, T, elasticity) # Initialize animation fig, ax = plt.subplots(figsize=(8, 5)) ax.set_xlim(0, max(max(x_no_drag), max(x_drag))) ax.set_ylim(0, max(max(y_no_drag), max(y_drag))) ax.set_xlabel(\"Distance [m]\") ax.set_ylabel(\"Height [m]\") ax.set_title(\"Projectile motion with and without air resistance (with bounces)\") ax.grid() point_no_drag, = ax.plot([], [], 'bo', label=\"Without air resistance\") point_drag, = ax.plot([], [], 'ro', label=\"With air resistance\") traj_no_drag, = ax.plot([], [], 'b--', alpha=0.5) traj_drag, = ax.plot([], [], 'r--', alpha=0.5) ax.legend() # Initialization function def init(): point_no_drag.set_data([], []) point_drag.set_data([], []) traj_no_drag.set_data([], []) traj_drag.set_data([], []) return point_no_drag, point_drag, traj_no_drag, traj_drag # Function to update the animation def update(frame): if frame < len(x_no_drag): point_no_drag.set_data([x_no_drag[frame]], [y_no_drag[frame]]) traj_no_drag.set_data(x_no_drag[:frame+1], y_no_drag[:frame+1]) if frame < len(x_drag): point_drag.set_data([x_drag[frame]], [y_drag[frame]]) traj_drag.set_data(x_drag[:frame+1], y_drag[:frame+1]) return point_no_drag, point_drag, traj_no_drag, traj_drag # Create animation frames = max(len(x_no_drag), len(x_drag)) ani = FuncAnimation(fig, update, frames=frames, init_func=init, blit=False, interval=20) # Display animation in Colab plt.close() HTML(ani.to_html5_video())","title":"1\ufe0f\u20e3 What Does This Code Do?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#link-to-the-simulation-above-on-google-colab","text":"https://colab.research.google.com/drive/1JAPKrMDEgJBFYaxuZgfnd50JqxAKGi-t?usp=sharing","title":"Link To The Simulation Above On Google Colab"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#7-conclusion","text":"The range equation follows a clear mathematical pattern. Maximum range occurs at 45\u00b0 , confirmed analytically and numerically. Including air resistance shows a significant reduction in range . This study has applications in sports, engineering, and physics simulations.","title":"7. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#8-references-further-reading","text":"Resnick, R., & Halliday, D. (2004). Fundamentals of Physics . MIT OpenCourseWare: Classical Mechanics Lectures. NASA\u2019s trajectory analysis for spacecraft launches.","title":"8. References &amp; Further Reading"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum: Theoretical and Computational Analysis Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The equation governing the motion of a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0 = \\sqrt{g/L}\\) for a simple pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force. For small angles ( \\(\\theta \\approx \\sin \\theta\\) ), the equation simplifies to a linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a homogeneous part (damped oscillation) and a particular part (forced oscillation). When the driving frequency approaches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), resonance occurs, leading to large oscillations. 2. Analysis of Dynamics We analyze the system by varying: - Damping coefficient ( \\(\\gamma\\) ) - Driving force amplitude ( \\(A\\) ) - Driving frequency ( \\(\\omega\\) ) Numerical Solution Using Python We use the Runge-Kutta method to solve the system numerically and visualize its dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equations of motion def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions tspan = [0, 50] # Time span y0 = [0.2, 0] # Initial angle and angular velocity # Solve the ODE sol = solve_ivp(forced_damped_pendulum, tspan, y0, args=(gamma, omega0, A, omega), t_eval=np.linspace(0, 50, 1000)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Theta (Angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() 3. Practical Applications The forced damped pendulum model is relevant in: - Energy harvesting devices : Utilizing resonance for energy collection. - Suspension bridges : Understanding oscillatory instabilities. - Oscillating circuits : Analogous behavior in RLC circuits. 4. Phase Portrait and Poincar\u00e9 Section A phase portrait illustrates the evolution of \\((\\theta, \\omega_\\theta)\\) over time, revealing transitions to chaos. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Diferansiyel Denklemi def pendulum(t, state, q, \u03a9, F): \u03b8, \u03c9 = state d\u03b8dt = \u03c9 d\u03c9dt = -q * \u03c9 - np.sin(\u03b8) + F * np.cos(\u03a9 * t) return [d\u03b8dt, d\u03c9dt] # Parametreler q = 0.5 # S\u00f6n\u00fcm katsay\u0131s\u0131 \u03a9 = 2/3 # Zorlanma frekans\u0131 F = 1.2 # Zorlanma kuvveti # Ba\u015flang\u0131\u00e7 ko\u015fullar\u0131: [\u03b8(0), \u03c9(0)] theta_0 = 0.2 omega_0 = 0.0 # Zaman aral\u0131\u011f\u0131 t_span = (0, 50) # 0 ile 50 saniye aras\u0131nda \u00e7\u00f6z\u00fcmle t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1000 zaman noktas\u0131 # \u00c7\u00f6z\u00fcm\u00fc Bul sol = solve_ivp(pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(q, \u03a9, F)) # Faz Portresi \u00c7izimi plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label=\"Faz Uzay\u0131 (\u03b8 vs \u03c9)\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"A\u00e7\u0131sal H\u0131z (rad/s)\") plt.title(\"Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Faz Portresi\") plt.legend() plt.grid() plt.show() alt text 5. Conclusion We explored the dynamics of a forced damped pendulum through theory and simulation. By varying parameters, we observed transitions from periodic motion to chaos. Future work could include: - Introducing nonlinear damping, - Exploring non-periodic driving forces. This study bridges theoretical physics with engineering applications, demonstrating the richness of nonlinear dynamical systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-theoretical-and-computational-analysis","text":"","title":"Forced Damped Pendulum: Theoretical and Computational Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The equation governing the motion of a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0 = \\sqrt{g/L}\\) for a simple pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force. For small angles ( \\(\\theta \\approx \\sin \\theta\\) ), the equation simplifies to a linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a homogeneous part (damped oscillation) and a particular part (forced oscillation). When the driving frequency approaches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), resonance occurs, leading to large oscillations.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"We analyze the system by varying: - Damping coefficient ( \\(\\gamma\\) ) - Driving force amplitude ( \\(A\\) ) - Driving frequency ( \\(\\omega\\) )","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-solution-using-python","text":"We use the Runge-Kutta method to solve the system numerically and visualize its dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equations of motion def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions tspan = [0, 50] # Time span y0 = [0.2, 0] # Initial angle and angular velocity # Solve the ODE sol = solve_ivp(forced_damped_pendulum, tspan, y0, args=(gamma, omega0, A, omega), t_eval=np.linspace(0, 50, 1000)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Theta (Angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Numerical Solution Using Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model is relevant in: - Energy harvesting devices : Utilizing resonance for energy collection. - Suspension bridges : Understanding oscillatory instabilities. - Oscillating circuits : Analogous behavior in RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-phase-portrait-and-poincare-section","text":"A phase portrait illustrates the evolution of \\((\\theta, \\omega_\\theta)\\) over time, revealing transitions to chaos. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Diferansiyel Denklemi def pendulum(t, state, q, \u03a9, F): \u03b8, \u03c9 = state d\u03b8dt = \u03c9 d\u03c9dt = -q * \u03c9 - np.sin(\u03b8) + F * np.cos(\u03a9 * t) return [d\u03b8dt, d\u03c9dt] # Parametreler q = 0.5 # S\u00f6n\u00fcm katsay\u0131s\u0131 \u03a9 = 2/3 # Zorlanma frekans\u0131 F = 1.2 # Zorlanma kuvveti # Ba\u015flang\u0131\u00e7 ko\u015fullar\u0131: [\u03b8(0), \u03c9(0)] theta_0 = 0.2 omega_0 = 0.0 # Zaman aral\u0131\u011f\u0131 t_span = (0, 50) # 0 ile 50 saniye aras\u0131nda \u00e7\u00f6z\u00fcmle t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1000 zaman noktas\u0131 # \u00c7\u00f6z\u00fcm\u00fc Bul sol = solve_ivp(pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(q, \u03a9, F)) # Faz Portresi \u00c7izimi plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label=\"Faz Uzay\u0131 (\u03b8 vs \u03c9)\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"A\u00e7\u0131sal H\u0131z (rad/s)\") plt.title(\"Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Faz Portresi\") plt.legend() plt.grid() plt.show() alt text","title":"4. Phase Portrait and Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-conclusion","text":"We explored the dynamics of a forced damped pendulum through theory and simulation. By varying parameters, we observed transitions from periodic motion to chaos. Future work could include: - Introducing nonlinear damping, - Exploring non-periodic driving forces. This study bridges theoretical physics with engineering applications, demonstrating the richness of nonlinear dynamical systems.","title":"5. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is fundamental in celestial mechanics. This law is critical for understanding planetary motion, satellite orbits, and gravitational interactions on different scales. By analyzing this relationship, we can: - Derive a mathematical connection between the orbital period and radius. - Discuss its implications in astronomy. - Analyze real-world examples such as the Moon\u2019s orbit around Earth. - Implement a computational model to simulate circular orbits and verify Kepler\u2019s Third Law. alt text Kepler\u2019s Third Law Derivation Kepler's Third Law states that for a planet orbiting a much more massive body, the square of the orbital period ( \\( \\(T\\) \\) ) is proportional to the cube of the semi-major axis ( \\( \\(r\\) \\) ): \\( \\(T^2 \\propto r^3\\) \\) alt text Mathematical Derivation From Newton's Law of Universal Gravitation: \\[F = \\frac{GMm}{r^2}\\] For a circular orbit, the required centripetal force is provided by gravity: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Since velocity in a circular orbit is: \\[v = \\frac{2 \\pi r}{T}\\] Substituting this into the force equation: \\[\\frac{GMm}{r^2} = \\frac{m}{r} \\left(\\frac{4\\pi^2 r^2}{T^2} \\right)\\] Simplifying and solving for \\( \\(T^2\\) \\) : \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\] This confirms Kepler\u2019s Third Law: \\[T^2 \\propto r^3\\] Implications in Astronomy Determining Planetary Masses: By measuring orbital periods and radii, we can estimate planetary and stellar masses. Predicting Satellite Orbits: Artificial satellites\u2019 orbits can be calculated using this relationship. Understanding Exoplanetary Systems: Kepler\u2019s Law helps infer exoplanet characteristics from observed orbital periods. Real-World Example: Moon's Orbit Around Earth The Moon's average distance from Earth: \\( \\(r = 3.84 \\times 10^8 m\\) \\) Orbital period: \\( \\(T = 27.3\\) \\) days Mass of Earth: \\( \\(M = 5.972 \\times 10^{24} kg\\) \\) Using our derived formula, we can verify Kepler\u2019s law numerically. Python Simulation of Circular Orbits The following Python script simulates planetary orbits and verifies Kepler\u2019s Third Law: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M = 5.972e24 # Mass of the Earth (kg) G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Orbital radii (m) orbit_radii = np.linspace(1e7, 4e8, 100) # Compute orbital periods using Kepler's Third Law orbital_periods = np.sqrt((4 * np.pi**2 * orbit_radii**3) / (G * M)) # Verify T^2 vs. r^3 relationship T_squared = orbital_periods**2 r_cubed = orbit_radii**3 # Plot results plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, label='$T^2 \\propto r^3$', color='blue') plt.xlabel('$r^3$ (m^3)') plt.ylabel('$T^2$ (s^2)') plt.title(\"Kepler's Third Law: $T^2$ vs. $r^3$\") plt.legend() plt.grid() plt.show() alt text Discussion on Elliptical Orbits Kepler\u2019s Third Law extends to elliptical orbits, where \\( \\(r\\) \\) is replaced by the semi-major axis. For binary systems, the sum of both masses is considered in the equation. The law helps analyze orbits of exoplanets, stars, and galaxies. alt text Conclusion Kepler\u2019s Third Law provides a crucial link between gravity and orbital mechanics. Our Python simulation confirms its validity, and its applications in astronomy are vast, from predicting satellite movements to discovering exoplanets.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"The relationship between the square of the orbital period and the cube of the orbital radius, known as Kepler's Third Law , is fundamental in celestial mechanics. This law is critical for understanding planetary motion, satellite orbits, and gravitational interactions on different scales. By analyzing this relationship, we can: - Derive a mathematical connection between the orbital period and radius. - Discuss its implications in astronomy. - Analyze real-world examples such as the Moon\u2019s orbit around Earth. - Implement a computational model to simulate circular orbits and verify Kepler\u2019s Third Law. alt text","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-derivation","text":"Kepler's Third Law states that for a planet orbiting a much more massive body, the square of the orbital period ( \\( \\(T\\) \\) ) is proportional to the cube of the semi-major axis ( \\( \\(r\\) \\) ): \\( \\(T^2 \\propto r^3\\) \\) alt text","title":"Kepler\u2019s Third Law Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#mathematical-derivation","text":"From Newton's Law of Universal Gravitation: \\[F = \\frac{GMm}{r^2}\\] For a circular orbit, the required centripetal force is provided by gravity: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Since velocity in a circular orbit is: \\[v = \\frac{2 \\pi r}{T}\\] Substituting this into the force equation: \\[\\frac{GMm}{r^2} = \\frac{m}{r} \\left(\\frac{4\\pi^2 r^2}{T^2} \\right)\\] Simplifying and solving for \\( \\(T^2\\) \\) : \\[T^2 = \\frac{4\\pi^2}{GM} r^3\\] This confirms Kepler\u2019s Third Law: \\[T^2 \\propto r^3\\]","title":"Mathematical Derivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-in-astronomy","text":"Determining Planetary Masses: By measuring orbital periods and radii, we can estimate planetary and stellar masses. Predicting Satellite Orbits: Artificial satellites\u2019 orbits can be calculated using this relationship. Understanding Exoplanetary Systems: Kepler\u2019s Law helps infer exoplanet characteristics from observed orbital periods.","title":"Implications in Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-example-moons-orbit-around-earth","text":"The Moon's average distance from Earth: \\( \\(r = 3.84 \\times 10^8 m\\) \\) Orbital period: \\( \\(T = 27.3\\) \\) days Mass of Earth: \\( \\(M = 5.972 \\times 10^{24} kg\\) \\) Using our derived formula, we can verify Kepler\u2019s law numerically.","title":"Real-World Example: Moon's Orbit Around Earth"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation-of-circular-orbits","text":"The following Python script simulates planetary orbits and verifies Kepler\u2019s Third Law: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M = 5.972e24 # Mass of the Earth (kg) G = 6.67430e-11 # Gravitational constant (m^3 kg^-1 s^-2) # Orbital radii (m) orbit_radii = np.linspace(1e7, 4e8, 100) # Compute orbital periods using Kepler's Third Law orbital_periods = np.sqrt((4 * np.pi**2 * orbit_radii**3) / (G * M)) # Verify T^2 vs. r^3 relationship T_squared = orbital_periods**2 r_cubed = orbit_radii**3 # Plot results plt.figure(figsize=(8,6)) plt.plot(r_cubed, T_squared, label='$T^2 \\propto r^3$', color='blue') plt.xlabel('$r^3$ (m^3)') plt.ylabel('$T^2$ (s^2)') plt.title(\"Kepler's Third Law: $T^2$ vs. $r^3$\") plt.legend() plt.grid() plt.show() alt text","title":"Python Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#discussion-on-elliptical-orbits","text":"Kepler\u2019s Third Law extends to elliptical orbits, where \\( \\(r\\) \\) is replaced by the semi-major axis. For binary systems, the sum of both masses is considered in the equation. The law helps analyze orbits of exoplanets, stars, and galaxies. alt text","title":"Discussion on Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler\u2019s Third Law provides a crucial link between gravity and orbital mechanics. Our Python simulation confirms its validity, and its applications in astronomy are vast, from predicting satellite movements to discovering exoplanets.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}