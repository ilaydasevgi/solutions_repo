{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Investigating the Range as a Function of the Angle of Projection Motivation Projectile motion is one of the most fundamental topics in classical mechanics. Despite its apparent simplicity, it provides a deep insight into the laws of motion and the effects of initial conditions on trajectory. The central question here is: \"How does the range (horizontal distance traveled) of a projectile depend on the angle at which it is launched?\" By investigating this, we uncover the elegant symmetry in projectile motion and how various physical parameters influence the outcome. 1. Theoretical Foundation We begin with the ideal case of projectile motion: - No air resistance - Constant gravitational acceleration \\( g \\) - Launch from ground level Let: - \\( v_0 \\) : initial launch speed - \\( \\theta \\) : launch angle (in degrees or radians) - \\( g \\) : gravitational acceleration - \\( R \\) : horizontal range - \\( T \\) : time of flight - \\( h = 0 \\) : launch and landing at the same height Equations of Motion Horizontal motion (no acceleration): \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion (accelerated): \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] At \\( y = 0 \\) , the projectile lands, giving total time of flight: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Substitute into \\( x(t) \\) to find range : Range Equation: \\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that: - The range depends sinusoidally on the angle - Maximum range occurs at \\( \\theta = 45^\\circ \\) - It's symmetric around \\( 45^\\circ \\) (e.g., \\( 30^\\circ \\) and \\( 60^\\circ \\) give same range) 2. Analysis of the Range Effect of Varying Launch Angle: From the formula: \\[ R(\\theta) = \\frac{v_0^2}{g} \\cdot \\sin(2\\theta) \\] We see that: - \\( R(\\theta) = R(90^\\circ - \\theta) \\) - Maximum at \\( \\theta = 45^\\circ \\) Effect of Initial Speed \\( v_0 \\) : Range increases quadratically with speed: \\[ R \\propto v_0^2 \\] Effect of Gravity \\( g \\) : Range is inversely proportional to gravity: \\[ R \\propto \\frac{1}{g} \\] Thus, on the Moon (where \\( g \\) is smaller), the range is longer for the same \\( v_0 \\) . 3. Practical Applications Real-world uses of projectile motion include: Sports : Basketball, soccer, archery (tuning angle for maximum distance) Engineering : Ballistics, cannon design Space physics : Lunar or Mars landings, estimating motion in low gravity More advanced models include: - Launching from an elevated position - Air resistance (drag force) - Wind or spin effects 4. Python Simulation: Range vs Angle We now simulate how the range changes with angle , keeping other parameters constant. Constants: import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 500) # launch angles in degrees angles_rad = np.radians(angles_deg) # Function to compute range def compute_range(v0, g, angles_rad): return (v0**2 * np.sin(2 * angles_rad)) / g # Single v0 case v0_single = 20 # m/s range_single = compute_range(v0_single, g, angles_rad) # Multiple v0s for comparison v0_list = [10, 20, 30] ranges_multiple = [compute_range(v, g, angles_rad) for v in v0_list] # Plot: Single Range vs. Angle plt.figure(figsize=(8, 5)) plt.plot(angles_deg, range_single, label=f'v0 = {v0_single} m/s', color='blue') plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Plot: Multiple Initial Velocities plt.figure(figsize=(8, 5)) for i, v0 in enumerate(v0_list): plt.plot(angles_deg, ranges_multiple[i], label=f'v0 = {v0} m/s') plt.title('Range vs. Angle for Different Launch Speeds') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion is one of the most fundamental topics in classical mechanics. Despite its apparent simplicity, it provides a deep insight into the laws of motion and the effects of initial conditions on trajectory. The central question here is: \"How does the range (horizontal distance traveled) of a projectile depend on the angle at which it is launched?\" By investigating this, we uncover the elegant symmetry in projectile motion and how various physical parameters influence the outcome.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"We begin with the ideal case of projectile motion: - No air resistance - Constant gravitational acceleration \\( g \\) - Launch from ground level Let: - \\( v_0 \\) : initial launch speed - \\( \\theta \\) : launch angle (in degrees or radians) - \\( g \\) : gravitational acceleration - \\( R \\) : horizontal range - \\( T \\) : time of flight - \\( h = 0 \\) : launch and landing at the same height","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal motion (no acceleration): \\[ x(t) = v_0 \\cos(\\theta) \\cdot t \\] Vertical motion (accelerated): \\[ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 \\] At \\( y = 0 \\) , the projectile lands, giving total time of flight: \\[ T = \\frac{2 v_0 \\sin(\\theta)}{g} \\] Substitute into \\( x(t) \\) to find range :","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"\\[ R = \\frac{v_0^2 \\sin(2\\theta)}{g} \\] This equation shows that: - The range depends sinusoidally on the angle - Maximum range occurs at \\( \\theta = 45^\\circ \\) - It's symmetric around \\( 45^\\circ \\) (e.g., \\( 30^\\circ \\) and \\( 60^\\circ \\) give same range)","title":"Range Equation:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-varying-launch-angle","text":"From the formula: \\[ R(\\theta) = \\frac{v_0^2}{g} \\cdot \\sin(2\\theta) \\] We see that: - \\( R(\\theta) = R(90^\\circ - \\theta) \\) - Maximum at \\( \\theta = 45^\\circ \\)","title":"Effect of Varying Launch Angle:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-initial-speed-v_0","text":"Range increases quadratically with speed: \\[ R \\propto v_0^2 \\]","title":"Effect of Initial Speed \\( v_0 \\):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#effect-of-gravity-g","text":"Range is inversely proportional to gravity: \\[ R \\propto \\frac{1}{g} \\] Thus, on the Moon (where \\( g \\) is smaller), the range is longer for the same \\( v_0 \\) .","title":"Effect of Gravity \\( g \\):"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Real-world uses of projectile motion include: Sports : Basketball, soccer, archery (tuning angle for maximum distance) Engineering : Ballistics, cannon design Space physics : Lunar or Mars landings, estimating motion in low gravity More advanced models include: - Launching from an elevated position - Air resistance (drag force) - Wind or spin effects","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-python-simulation-range-vs-angle","text":"We now simulate how the range changes with angle , keeping other parameters constant.","title":"4. Python Simulation: Range vs Angle"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"import numpy as np import matplotlib.pyplot as plt # Constants g = 9.81 # gravitational acceleration (m/s^2) angles_deg = np.linspace(0, 90, 500) # launch angles in degrees angles_rad = np.radians(angles_deg) # Function to compute range def compute_range(v0, g, angles_rad): return (v0**2 * np.sin(2 * angles_rad)) / g # Single v0 case v0_single = 20 # m/s range_single = compute_range(v0_single, g, angles_rad) # Multiple v0s for comparison v0_list = [10, 20, 30] ranges_multiple = [compute_range(v, g, angles_rad) for v in v0_list] # Plot: Single Range vs. Angle plt.figure(figsize=(8, 5)) plt.plot(angles_deg, range_single, label=f'v0 = {v0_single} m/s', color='blue') plt.axvline(45, color='red', linestyle='--', label='Max Range at 45\u00b0') plt.title('Projectile Range vs. Launch Angle') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.tight_layout() plt.show() # Plot: Multiple Initial Velocities plt.figure(figsize=(8, 5)) for i, v0 in enumerate(v0_list): plt.plot(angles_deg, ranges_multiple[i], label=f'v0 = {v0} m/s') plt.title('Range vs. Angle for Different Launch Speeds') plt.xlabel('Angle (degrees)') plt.ylabel('Range (meters)') plt.legend() plt.grid(True) plt.tight_layout() plt.show()","title":"Constants:"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Forced Damped Pendulum: Theoretical and Computational Analysis Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The equation governing the motion of a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0 = \\sqrt{g/L}\\) for a simple pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force. For small angles ( \\(\\theta \\approx \\sin \\theta\\) ), the equation simplifies to a linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a homogeneous part (damped oscillation) and a particular part (forced oscillation). When the driving frequency approaches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), resonance occurs, leading to large oscillations. 2. Analysis of Dynamics We analyze the system by varying: - Damping coefficient ( \\(\\gamma\\) ) - Driving force amplitude ( \\(A\\) ) - Driving frequency ( \\(\\omega\\) ) Numerical Solution Using Python We use the Runge-Kutta method to solve the system numerically and visualize its dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equations of motion def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions tspan = [0, 50] # Time span y0 = [0.2, 0] # Initial angle and angular velocity # Solve the ODE sol = solve_ivp(forced_damped_pendulum, tspan, y0, args=(gamma, omega0, A, omega), t_eval=np.linspace(0, 50, 1000)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Theta (Angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() 3. Practical Applications The forced damped pendulum model is relevant in: - Energy harvesting devices : Utilizing resonance for energy collection. - Suspension bridges : Understanding oscillatory instabilities. - Oscillating circuits : Analogous behavior in RLC circuits. 4. Phase Portrait and Poincar\u00e9 Section A phase portrait illustrates the evolution of \\((\\theta, \\omega_\\theta)\\) over time, revealing transitions to chaos. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Diferansiyel Denklemi def pendulum(t, state, q, \u03a9, F): \u03b8, \u03c9 = state d\u03b8dt = \u03c9 d\u03c9dt = -q * \u03c9 - np.sin(\u03b8) + F * np.cos(\u03a9 * t) return [d\u03b8dt, d\u03c9dt] # Parametreler q = 0.5 # S\u00f6n\u00fcm katsay\u0131s\u0131 \u03a9 = 2/3 # Zorlanma frekans\u0131 F = 1.2 # Zorlanma kuvveti # Ba\u015flang\u0131\u00e7 ko\u015fullar\u0131: [\u03b8(0), \u03c9(0)] theta_0 = 0.2 omega_0 = 0.0 # Zaman aral\u0131\u011f\u0131 t_span = (0, 50) # 0 ile 50 saniye aras\u0131nda \u00e7\u00f6z\u00fcmle t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1000 zaman noktas\u0131 # \u00c7\u00f6z\u00fcm\u00fc Bul sol = solve_ivp(pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(q, \u03a9, F)) # Faz Portresi \u00c7izimi plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label=\"Faz Uzay\u0131 (\u03b8 vs \u03c9)\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"A\u00e7\u0131sal H\u0131z (rad/s)\") plt.title(\"Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Faz Portresi\") plt.legend() plt.grid() plt.show() 5. Conclusion We explored the dynamics of a forced damped pendulum through theory and simulation. By varying parameters, we observed transitions from periodic motion to chaos. Future work could include: - Introducing nonlinear damping, - Exploring non-periodic driving forces. This study bridges theoretical physics with engineering applications, demonstrating the richness of nonlinear dynamical systems.","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-damped-pendulum-theoretical-and-computational-analysis","text":"","title":"Forced Damped Pendulum: Theoretical and Computational Analysis"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The equation governing the motion of a forced damped pendulum is given by: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = A \\cos(\\omega t) \\] where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(\\omega_0\\) is the natural frequency ( \\(\\omega_0 = \\sqrt{g/L}\\) for a simple pendulum), - \\(A\\) is the amplitude of the external driving force, - \\(\\omega\\) is the frequency of the external driving force. For small angles ( \\(\\theta \\approx \\sin \\theta\\) ), the equation simplifies to a linear differential equation: \\[ \\frac{d^2\\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] The general solution consists of a homogeneous part (damped oscillation) and a particular part (forced oscillation). When the driving frequency approaches the natural frequency ( \\(\\omega \\approx \\omega_0\\) ), resonance occurs, leading to large oscillations.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"We analyze the system by varying: - Damping coefficient ( \\(\\gamma\\) ) - Driving force amplitude ( \\(A\\) ) - Driving frequency ( \\(\\omega\\) )","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-solution-using-python","text":"We use the Runge-Kutta method to solve the system numerically and visualize its dynamics. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define the equations of motion def forced_damped_pendulum(t, y, gamma, omega0, A, omega): theta, omega_theta = y dtheta_dt = omega_theta domega_dt = -gamma * omega_theta - omega0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Parameters gamma = 0.5 # Damping coefficient omega0 = 1.0 # Natural frequency A = 1.2 # Driving force amplitude omega = 2.0 # Driving frequency # Initial conditions tspan = [0, 50] # Time span y0 = [0.2, 0] # Initial angle and angular velocity # Solve the ODE sol = solve_ivp(forced_damped_pendulum, tspan, y0, args=(gamma, omega0, A, omega), t_eval=np.linspace(0, 50, 1000)) # Plot results plt.figure(figsize=(10, 5)) plt.plot(sol.t, sol.y[0], label=\"Theta (Angle)\") plt.xlabel(\"Time\") plt.ylabel(\"Theta (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"Numerical Solution Using Python"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"The forced damped pendulum model is relevant in: - Energy harvesting devices : Utilizing resonance for energy collection. - Suspension bridges : Understanding oscillatory instabilities. - Oscillating circuits : Analogous behavior in RLC circuits.","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-phase-portrait-and-poincare-section","text":"A phase portrait illustrates the evolution of \\((\\theta, \\omega_\\theta)\\) over time, revealing transitions to chaos. import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Diferansiyel Denklemi def pendulum(t, state, q, \u03a9, F): \u03b8, \u03c9 = state d\u03b8dt = \u03c9 d\u03c9dt = -q * \u03c9 - np.sin(\u03b8) + F * np.cos(\u03a9 * t) return [d\u03b8dt, d\u03c9dt] # Parametreler q = 0.5 # S\u00f6n\u00fcm katsay\u0131s\u0131 \u03a9 = 2/3 # Zorlanma frekans\u0131 F = 1.2 # Zorlanma kuvveti # Ba\u015flang\u0131\u00e7 ko\u015fullar\u0131: [\u03b8(0), \u03c9(0)] theta_0 = 0.2 omega_0 = 0.0 # Zaman aral\u0131\u011f\u0131 t_span = (0, 50) # 0 ile 50 saniye aras\u0131nda \u00e7\u00f6z\u00fcmle t_eval = np.linspace(t_span[0], t_span[1], 1000) # 1000 zaman noktas\u0131 # \u00c7\u00f6z\u00fcm\u00fc Bul sol = solve_ivp(pendulum, t_span, [theta_0, omega_0], t_eval=t_eval, args=(q, \u03a9, F)) # Faz Portresi \u00c7izimi plt.figure(figsize=(8, 6)) plt.plot(sol.y[0], sol.y[1], label=\"Faz Uzay\u0131 (\u03b8 vs \u03c9)\") plt.xlabel(\"Theta (rad)\") plt.ylabel(\"A\u00e7\u0131sal H\u0131z (rad/s)\") plt.title(\"Zorlanm\u0131\u015f S\u00f6n\u00fcml\u00fc Sarkac\u0131n Faz Portresi\") plt.legend() plt.grid() plt.show()","title":"4. Phase Portrait and Poincar\u00e9 Section"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-conclusion","text":"We explored the dynamics of a forced damped pendulum through theory and simulation. By varying parameters, we observed transitions from periodic motion to chaos. Future work could include: - Introducing nonlinear damping, - Exploring non-periodic driving forces. This study bridges theoretical physics with engineering applications, demonstrating the richness of nonlinear dynamical systems.","title":"5. Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Orbital Period and Orbital Radius Motivation Kepler's Third Law states that the square of the orbital period \\( \\(T\\) \\) of a planet is proportional to the cube of the semi-major axis (orbital radius) \\( \\(r\\) \\) of its orbit. Mathematically: \\[T^2 \\propto r^3\\] This fundamental relationship allows us to: - Predict planetary motions - Calculate planetary masses and distances - Understand gravitational interactions in celestial mechanics What is The Kepler Law Kepler's Laws of Planetary Motion Johannes Kepler formulated three laws that describe the motion of planets around the Sun: 1. Law of Ellipses Each planet moves in an elliptical orbit with the Sun at one focus . An ellipse is mathematically represented by: \\[ \\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1 \\] Where: - \\( a \\) : semi-major axis - \\( b \\) : semi-minor axis 2. Law of Equal Areas A line segment joining a planet and the Sun sweeps out equal areas in equal times . This implies the planet moves faster when closer to the Sun and slower when farther . Mathematically: \\[ \\frac{dA}{dt} = \\text{constant} \\] Where: - \\( A \\) : area swept out - \\( t \\) : time 3. Law of Harmonies The square of the orbital period \\( T \\) of a planet is proportional to the cube of the semi-major axis \\( a \\) of its orbit: \\[ T^2 \\propto a^3 \\] Or for two planets orbiting the same star: \\[ \\frac{T_1^2}{a_1^3} = \\frac{T_2^2}{a_2^3} \\] Where: - \\( T \\) : orbital period (in years) - \\( a \\) : semi-major axis (in astronomical units) 1. Derivation of the Relationship To derive Kepler's Third Law, we start with Newton\u2019s Law of Gravitation: \\[F = \\frac{GMm}{r^2}\\] where: - \\( \\(G\\) \\) is the gravitational constant, - \\( \\(M\\) \\) is the mass of the central body, - \\( \\(m\\) \\) is the mass of the orbiting object, - \\( \\(r\\) \\) is the orbital radius. For circular orbits, the centripetal force is provided by gravity: \\[F = \\frac{m v^2}{r}\\] Equating gravitational force to centripetal force: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Canceling \\( \\(m\\) \\) and rearranging: \\[v^2 = \\frac{GM}{r}\\] The orbital period is given by: \\[T = \\frac{2\\pi r}{v}\\] Substituting \\( \\(v\\) \\) : \\[T = \\frac{2\\pi r}{\\sqrt{GM/r}}\\] Squaring both sides: \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] Thus, we arrive at Kepler's Third Law: \\[T^2 \\propto r^3\\] 2. Implications for Astronomy Kepler's Third Law is crucial in: - Determining planetary masses and distances using observed orbital periods - Satellite and spacecraft navigation - Studying exoplanetary systems Real-World Examples Moon's Orbit Around Earth : Period: \\( \\(T_{moon} \\approx 27.3\\) \\) days Radius: \\( \\(r_{moon} \\approx 3.84 \\times 10^5\\) \\) km Planets in the Solar System : For Earth: \\( \\(T = 1\\) \\) year, \\( \\(r = 1 AU\\) \\) For Mars: \\( \\(T = 1.88\\) \\) years, \\( \\(r = 1.52 AU\\) \\) (follows \\( \\(T^2 \\propto r^3\\) \\) ) 3. Computational Simulation of Circular Orbits Below is a Python script that simulates circular orbits and verifies Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # 1 Astronomical Unit in meters # Function to compute orbital period def orbital_period(r, M): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital radii in AU radii_AU = np.linspace(0.1, 5, 10) radii_m = radii_AU * AU # Compute periods periods = orbital_period(radii_m, M_sun) / (60 * 60 * 24 * 365) # Convert to years # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii_m**3, periods**2, 'bo-', label='$T^2$ vs $r^3$') plt.xlabel('$r^3$ (m^3)') plt.ylabel('$T^2$ (years^2)') plt.title('Verification of Kepler\\'s Third Law') plt.legend() plt.grid() plt.show() 4. Extension to Elliptical Orbits Kepler's Third Law also applies to elliptical orbits , where: \\(r\\) is replaced by the semi-major axis \\(a\\) The relationship still holds: \\( \\(T^2 \\propto a^3\\) \\) This generalization allows for: - Understanding cometary orbits (e.g., Halley's Comet) - Studying binary star systems - Determining galactic dynamics Conclusion Kepler's Third Law provides a direct link between orbital periods and radii. It helps predict planetary motions and system dynamics . Computational models confirm the theoretical relationship. The law extends to elliptical orbits and cosmic scales . References Kepler, J. Astronomia Nova (1609) Newton, I. Principia Mathematica (1687) NASA Planetary Data","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law states that the square of the orbital period \\( \\(T\\) \\) of a planet is proportional to the cube of the semi-major axis (orbital radius) \\( \\(r\\) \\) of its orbit. Mathematically: \\[T^2 \\propto r^3\\] This fundamental relationship allows us to: - Predict planetary motions - Calculate planetary masses and distances - Understand gravitational interactions in celestial mechanics","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#what-is-the-kepler-law","text":"","title":"What is The Kepler Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-laws-of-planetary-motion","text":"Johannes Kepler formulated three laws that describe the motion of planets around the Sun:","title":"Kepler's Laws of Planetary Motion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-law-of-ellipses","text":"Each planet moves in an elliptical orbit with the Sun at one focus . An ellipse is mathematically represented by: \\[ \\frac{x^2}{a^2} + \\frac{y^2}{b^2} = 1 \\] Where: - \\( a \\) : semi-major axis - \\( b \\) : semi-minor axis","title":"1. Law of Ellipses"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-law-of-equal-areas","text":"A line segment joining a planet and the Sun sweeps out equal areas in equal times . This implies the planet moves faster when closer to the Sun and slower when farther . Mathematically: \\[ \\frac{dA}{dt} = \\text{constant} \\] Where: - \\( A \\) : area swept out - \\( t \\) : time","title":"2. Law of Equal Areas"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-law-of-harmonies","text":"The square of the orbital period \\( T \\) of a planet is proportional to the cube of the semi-major axis \\( a \\) of its orbit: \\[ T^2 \\propto a^3 \\] Or for two planets orbiting the same star: \\[ \\frac{T_1^2}{a_1^3} = \\frac{T_2^2}{a_2^3} \\] Where: - \\( T \\) : orbital period (in years) - \\( a \\) : semi-major axis (in astronomical units)","title":"3. Law of Harmonies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-derivation-of-the-relationship","text":"To derive Kepler's Third Law, we start with Newton\u2019s Law of Gravitation: \\[F = \\frac{GMm}{r^2}\\] where: - \\( \\(G\\) \\) is the gravitational constant, - \\( \\(M\\) \\) is the mass of the central body, - \\( \\(m\\) \\) is the mass of the orbiting object, - \\( \\(r\\) \\) is the orbital radius. For circular orbits, the centripetal force is provided by gravity: \\[F = \\frac{m v^2}{r}\\] Equating gravitational force to centripetal force: \\[\\frac{GMm}{r^2} = \\frac{m v^2}{r}\\] Canceling \\( \\(m\\) \\) and rearranging: \\[v^2 = \\frac{GM}{r}\\] The orbital period is given by: \\[T = \\frac{2\\pi r}{v}\\] Substituting \\( \\(v\\) \\) : \\[T = \\frac{2\\pi r}{\\sqrt{GM/r}}\\] Squaring both sides: \\[T^2 = \\frac{4\\pi^2 r^3}{GM}\\] Thus, we arrive at Kepler's Third Law: \\[T^2 \\propto r^3\\]","title":"1. Derivation of the Relationship"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-implications-for-astronomy","text":"Kepler's Third Law is crucial in: - Determining planetary masses and distances using observed orbital periods - Satellite and spacecraft navigation - Studying exoplanetary systems","title":"2. Implications for Astronomy"},{"location":"1%20Physics/2%20Gravity/Problem_1/#real-world-examples","text":"Moon's Orbit Around Earth : Period: \\( \\(T_{moon} \\approx 27.3\\) \\) days Radius: \\( \\(r_{moon} \\approx 3.84 \\times 10^5\\) \\) km Planets in the Solar System : For Earth: \\( \\(T = 1\\) \\) year, \\( \\(r = 1 AU\\) \\) For Mars: \\( \\(T = 1.88\\) \\) years, \\( \\(r = 1.52 AU\\) \\) (follows \\( \\(T^2 \\propto r^3\\) \\) )","title":"Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-computational-simulation-of-circular-orbits","text":"Below is a Python script that simulates circular orbits and verifies Kepler's Third Law: import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M_sun = 1.989e30 # Mass of the Sun in kg AU = 1.496e11 # 1 Astronomical Unit in meters # Function to compute orbital period def orbital_period(r, M): return 2 * np.pi * np.sqrt(r**3 / (G * M)) # Orbital radii in AU radii_AU = np.linspace(0.1, 5, 10) radii_m = radii_AU * AU # Compute periods periods = orbital_period(radii_m, M_sun) / (60 * 60 * 24 * 365) # Convert to years # Plot T^2 vs r^3 plt.figure(figsize=(8,6)) plt.plot(radii_m**3, periods**2, 'bo-', label='$T^2$ vs $r^3$') plt.xlabel('$r^3$ (m^3)') plt.ylabel('$T^2$ (years^2)') plt.title('Verification of Kepler\\'s Third Law') plt.legend() plt.grid() plt.show()","title":"3. Computational Simulation of Circular Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-extension-to-elliptical-orbits","text":"Kepler's Third Law also applies to elliptical orbits , where: \\(r\\) is replaced by the semi-major axis \\(a\\) The relationship still holds: \\( \\(T^2 \\propto a^3\\) \\) This generalization allows for: - Understanding cometary orbits (e.g., Halley's Comet) - Studying binary star systems - Determining galactic dynamics","title":"4. Extension to Elliptical Orbits"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"Kepler's Third Law provides a direct link between orbital periods and radii. It helps predict planetary motions and system dynamics . Computational models confirm the theoretical relationship. The law extends to elliptical orbits and cosmic scales .","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#references","text":"Kepler, J. Astronomia Nova (1609) Newton, I. Principia Mathematica (1687) NASA Planetary Data","title":"References"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Motivation The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions. 1. Definitions of Cosmic Velocities First Cosmic Velocity (Orbital Velocity) The minimum velocity required for a body to stay in a stable circular orbit around a celestial body. Derived using centripetal force balance with gravitational force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$ Second Cosmic Velocity (Escape Velocity) The minimum velocity required to escape a celestial body\u2019s gravitational field. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$ Third Cosmic Velocity (Solar System Escape Velocity) The minimum velocity required to escape both the planet\u2019s gravity and the Sun\u2019s gravitational influence. Derived from combining the escape velocity of the planet and the escape velocity from the Sun: $$ v_3 = \\sqrt{v_{\\text{escape, planet}}^2 + v_{\\text{escape, sun}}^2} $$ 2. Mathematical Derivations and Parameters Affecting These Velocities Gravitational constant (G) : \\( 6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) Mass of celestial body (M) Radius of celestial body (R) For third cosmic velocity, Sun's mass and distance are also considered. 3. Python Code to Calculate and Visualize Cosmic Velocities import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in m) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Compute velocities velocities = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots(figsize=(8, 6)) x_labels = list(velocities.keys()) v1_vals = [velocities[body][0] for body in x_labels] v2_vals = [velocities[body][1] for body in x_labels] ax.bar(x_labels, v1_vals, label=\"First Cosmic Velocity (km/s)\", color=\"blue\") ax.bar(x_labels, v2_vals, label=\"Second Cosmic Velocity (km/s)\", color=\"red\", alpha=0.7) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"First and Second Cosmic Velocities for Celestial Bodies\") ax.legend() plt.show() 4. Discussion on Space Exploration Satellites : Launched at first cosmic velocity to remain in orbit. Interplanetary Missions : Rockets must reach at least second cosmic velocity to escape Earth's gravity. Interstellar Travel : Requires surpassing the third cosmic velocity to leave the Sun\u2019s gravitational influence.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is crucial for understanding the conditions required to leave a celestial body's gravitational influence. Extending this concept, the first, second, and third cosmic velocities define the thresholds for orbiting, escaping, and leaving a star system. These principles underpin modern space exploration, from launching satellites to interplanetary missions.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#1-definitions-of-cosmic-velocities","text":"","title":"1. Definitions of Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"The minimum velocity required for a body to stay in a stable circular orbit around a celestial body. Derived using centripetal force balance with gravitational force: $$ v_1 = \\sqrt{\\frac{GM}{R}} $$","title":"First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"The minimum velocity required to escape a celestial body\u2019s gravitational field. Derived from energy conservation: $$ v_2 = \\sqrt{\\frac{2GM}{R}} $$","title":"Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity-solar-system-escape-velocity","text":"The minimum velocity required to escape both the planet\u2019s gravity and the Sun\u2019s gravitational influence. Derived from combining the escape velocity of the planet and the escape velocity from the Sun: $$ v_3 = \\sqrt{v_{\\text{escape, planet}}^2 + v_{\\text{escape, sun}}^2} $$","title":"Third Cosmic Velocity (Solar System Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#2-mathematical-derivations-and-parameters-affecting-these-velocities","text":"Gravitational constant (G) : \\( 6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2} \\) Mass of celestial body (M) Radius of celestial body (R) For third cosmic velocity, Sun's mass and distance are also considered.","title":"2. Mathematical Derivations and Parameters Affecting These Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#3-python-code-to-calculate-and-visualize-cosmic-velocities","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674 * 10**-11 # Gravitational constant (m^3 kg^-1 s^-2) # Celestial body data (mass in kg, radius in m) bodies = { \"Earth\": {\"mass\": 5.972e24, \"radius\": 6.371e6}, \"Mars\": {\"mass\": 6.417e23, \"radius\": 3.389e6}, \"Jupiter\": {\"mass\": 1.898e27, \"radius\": 6.9911e7} } # Compute velocities velocities = {} for body, data in bodies.items(): M = data[\"mass\"] R = data[\"radius\"] v1 = np.sqrt(G * M / R) # First cosmic velocity v2 = np.sqrt(2 * G * M / R) # Second cosmic velocity velocities[body] = (v1, v2) # Visualization fig, ax = plt.subplots(figsize=(8, 6)) x_labels = list(velocities.keys()) v1_vals = [velocities[body][0] for body in x_labels] v2_vals = [velocities[body][1] for body in x_labels] ax.bar(x_labels, v1_vals, label=\"First Cosmic Velocity (km/s)\", color=\"blue\") ax.bar(x_labels, v2_vals, label=\"Second Cosmic Velocity (km/s)\", color=\"red\", alpha=0.7) ax.set_ylabel(\"Velocity (m/s)\") ax.set_title(\"First and Second Cosmic Velocities for Celestial Bodies\") ax.legend() plt.show()","title":"3. Python Code to Calculate and Visualize Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#4-discussion-on-space-exploration","text":"Satellites : Launched at first cosmic velocity to remain in orbit. Interplanetary Missions : Rockets must reach at least second cosmic velocity to escape Earth's gravity. Interstellar Travel : Requires surpassing the third cosmic velocity to leave the Sun\u2019s gravitational influence.","title":"4. Discussion on Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Before diving into theory, explore how real spacecraft move using NASA\u2019s official 3D simulation platform: \ud83c\udf10 NASA Eyes on the Solar System Real-time orbits, mission tracking, and gravity interactions! Motivation When a payload is released from a moving rocket near Earth, it can follow a wide range of trajectories based on its initial speed, direction, and altitude . These can include: Reentry into Earth\u2019s atmosphere, Stable orbits (elliptical or circular), Escape into space. Understanding these trajectories is crucial for: Satellite deployment, Reentry planning, Interplanetary missions. This problem blends orbital mechanics with numerical simulation , providing practical insight into real-world space mission planning. Governing Physics To better understand gravitational attraction and orbital motion, you can explore this interactive simulation: \ud83c\udf10 PhET: Gravity and Orbits Visualize how mass, distance, and velocity affect planetary orbits and satellite motion in real time! Newton\u2019s Law of Universal Gravitation The gravitational force acting on a payload is: \\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\( G = 6.674 \\times 10^{-11} \\, \\text{m}^3/\\text{kg} \\cdot \\text{s}^2 \\) is the gravitational constant, \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) is Earth\u2019s mass, \\( m \\) is the mass of the payload (cancels out later), \\( r \\) is the distance between Earth\u2019s center and the payload, \\( \\hat{r} \\) is the unit vector pointing toward Earth\u2019s center. Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = -\\frac{GM}{r^2} \\hat{r} \\] This gives us the acceleration at any point, which we use for simulation. Orbital Energy and Trajectories Total specific mechanical energy of the payload: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\( \\epsilon < 0 \\) : Elliptical orbit (bound) \\( \\epsilon = 0 \\) : Parabolic trajectory (escape) \\( \\epsilon > 0 \\) : Hyperbolic trajectory (escape) Escape velocity at distance \\( r \\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Escape velocity decreases with altitude since gravitational pull weakens. It is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Below is a plot showing how escape velocity changes with altitude: Numerical Simulation (Euler Method) We use the Euler method to simulate the motion of the payload. It updates position and velocity step-by-step using: \\[ \\vec{v}_{n+1} = \\vec{v}_n + \\vec{a}_n \\cdot \\Delta t \\] \\[ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_{n+1} \\cdot \\Delta t \\] Assumptions: Earth is a point mass at origin. Motion is in 2D space (x, y). Only gravity affects the payload (no atmosphere, drag, etc.). Python Implementation Google Collab Link For Python Implementation \ud83d\udd0d Explore Further: Beyond Earth While this project focuses on payloads near Earth, it's also valuable to understand more complex gravitational dynamics. \ud83c\udfa5 SkyMarvels\u2122 \u2013 Solar System Barycenter How the Sun moves due to gravitational pulls from the planets \u2014 visualized with Celestia. Barycenters explain why the Sun itself moves slightly \u2014 important for understanding motion in multi-body systems.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"Before diving into theory, explore how real spacecraft move using NASA\u2019s official 3D simulation platform: \ud83c\udf10 NASA Eyes on the Solar System Real-time orbits, mission tracking, and gravity interactions!","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#motivation","text":"When a payload is released from a moving rocket near Earth, it can follow a wide range of trajectories based on its initial speed, direction, and altitude . These can include: Reentry into Earth\u2019s atmosphere, Stable orbits (elliptical or circular), Escape into space. Understanding these trajectories is crucial for: Satellite deployment, Reentry planning, Interplanetary missions. This problem blends orbital mechanics with numerical simulation , providing practical insight into real-world space mission planning.","title":"Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#governing-physics","text":"To better understand gravitational attraction and orbital motion, you can explore this interactive simulation: \ud83c\udf10 PhET: Gravity and Orbits Visualize how mass, distance, and velocity affect planetary orbits and satellite motion in real time!","title":"Governing Physics"},{"location":"1%20Physics/2%20Gravity/Problem_3/#newtons-law-of-universal-gravitation","text":"The gravitational force acting on a payload is: \\[ \\vec{F} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\( G = 6.674 \\times 10^{-11} \\, \\text{m}^3/\\text{kg} \\cdot \\text{s}^2 \\) is the gravitational constant, \\( M = 5.972 \\times 10^{24} \\, \\text{kg} \\) is Earth\u2019s mass, \\( m \\) is the mass of the payload (cancels out later), \\( r \\) is the distance between Earth\u2019s center and the payload, \\( \\hat{r} \\) is the unit vector pointing toward Earth\u2019s center. Using Newton\u2019s Second Law: \\[ \\vec{a} = \\frac{\\vec{F}}{m} = -\\frac{GM}{r^2} \\hat{r} \\] This gives us the acceleration at any point, which we use for simulation.","title":"Newton\u2019s Law of Universal Gravitation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#orbital-energy-and-trajectories","text":"Total specific mechanical energy of the payload: \\[ \\epsilon = \\frac{v^2}{2} - \\frac{GM}{r} \\] \\( \\epsilon < 0 \\) : Elliptical orbit (bound) \\( \\epsilon = 0 \\) : Parabolic trajectory (escape) \\( \\epsilon > 0 \\) : Hyperbolic trajectory (escape) Escape velocity at distance \\( r \\) : \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Escape velocity decreases with altitude since gravitational pull weakens. It is given by: \\[ v_{\\text{esc}} = \\sqrt{\\frac{2GM}{r}} \\] Below is a plot showing how escape velocity changes with altitude:","title":"Orbital Energy and Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#numerical-simulation-euler-method","text":"We use the Euler method to simulate the motion of the payload. It updates position and velocity step-by-step using: \\[ \\vec{v}_{n+1} = \\vec{v}_n + \\vec{a}_n \\cdot \\Delta t \\] \\[ \\vec{r}_{n+1} = \\vec{r}_n + \\vec{v}_{n+1} \\cdot \\Delta t \\]","title":"Numerical Simulation (Euler Method)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#assumptions","text":"Earth is a point mass at origin. Motion is in 2D space (x, y). Only gravity affects the payload (no atmosphere, drag, etc.).","title":"Assumptions:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-implementation","text":"Google Collab Link For Python Implementation","title":"Python Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#explore-further-beyond-earth","text":"While this project focuses on payloads near Earth, it's also valuable to understand more complex gravitational dynamics. \ud83c\udfa5 SkyMarvels\u2122 \u2013 Solar System Barycenter How the Sun moves due to gravitational pulls from the planets \u2014 visualized with Celestia. Barycenters explain why the Sun itself moves slightly \u2014 important for understanding motion in multi-body systems.","title":"\ud83d\udd0d Explore Further: Beyond Earth"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Interference Patterns on a Water Surface Motivation Interference occurs when waves from multiple sources overlap in space, creating new wave patterns. On a water surface, this is easily observed when circular ripples from different points intersect, producing interference patterns . These patterns reveal: Constructive interference : where waves reinforce each other Destructive interference : where waves cancel each other Studying such patterns helps us understand: Superposition principle Phase relationships between waves Real-world wave interactions Problem Statement We aim to simulate and analyze the interference pattern created by circular waves emitted from coherent point sources located at the vertices of a regular polygon . Theoretical Background Single Circular Wave The disturbance caused by a single point source at position \\( (x_0, y_0) \\) on the water surface is modeled by: \\[ u(x, y, t) = A \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\( u(x, y, t) \\) : Displacement at position \\( (x, y) \\) and time \\( t \\) \\( A \\) : Amplitude \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number \\( \\lambda \\) : Wavelength \\( \\omega = 2\\pi f \\) : Angular frequency \\( f \\) : Frequency \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : Distance from source to point \\( \\phi \\) : Initial phase Superposition of Waves If there are \\( N \\) identical, coherent wave sources, the total displacement at any point \\( (x, y) \\) is: \\[ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : Distance from the \\( i^\\text{th} \\) source to point \\( (x, y) \\) Simulation: Square Configuration (4 Sources) We simulate 4 point sources placed at the vertices of a square , centered at the origin. Simulation Parameters Polygon type: Square (4 vertices) Radius \\( R = 1 \\) Amplitude \\( A = 1 \\) Wavelength \\( \\lambda = 1 \\) Frequency \\( f = 1 \\) Phase \\( \\phi = 0 \\) Time snapshot \\( t = 0 \\) Python Code The following Python script simulates the interference pattern produced by four coherent wave sources placed at the vertices of a square , centered at the origin. Each source emits circular waves with the same amplitude, wavelength, and frequency. The wave equation used for each point source is: \\[ u(x, y, t) = A \\cdot \\cos(k r - \\omega t + \\phi) \\] The total displacement is calculated by the superposition of waves from all sources: \\[ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Here\u2019s the full Python implementation: import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 wavelength = 1 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t = 0 # single time snapshot # Grid setup x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Square: 4 vertices on a circle N = 4 R = 1 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] # Superposition of waves Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * r - omega * t + phi) # Plotting plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, Z, shading='auto', cmap='RdBu') plt.colorbar(label='Water Surface Displacement $u(x, y)$') plt.scatter(*zip(*sources), color='black', marker='o', label='Sources') plt.title('Interference Pattern from 4 Point Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.tight_layout() plt.show() Interference Patterns from Multiple Sources These plots show the interference patterns generated by point wave sources arranged in regular polygonal shapes. The constructive and destructive interference of sinusoidal waves produces these beautiful and symmetric patterns. 1. 3-Source Interference Pattern (Equilateral Triangle) This pattern results from three wave sources placed at the vertices of an equilateral triangle . Each source emits waves of the same frequency and amplitude. Interference occurs where waves overlap . The symmetry of the triangle creates a rotationally symmetric interference pattern. You observe both constructive (bright/red) and destructive (dark/blue) interference zones. There is no analytical formula for the full pattern, but each source contributes: \\[ U_i(x, y) = \\sin(k r_i) \\] where: - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) - \\( k \\) : wave number The total displacement is: \\[ U(x, y) = \\sum_{i=1}^{3} \\sin(k r_i) \\] 2. 5-Source Interference Pattern (Regular Pentagon) In this case, five sources are placed evenly on a circle, forming a regular pentagon . More sources result in finer interference fringes . The structure exhibits fivefold symmetry . The increased number of waves introduces complex wavefront interactions . The superposition principle still applies: \\[ U(x, y) = \\sum_{i=1}^{5} \\sin(k r_i) \\] As \\( n \\) increases, the pattern becomes denser and more circular. \ud83d\udd37 3. 6-Source Interference Pattern (Regular Hexagon) This setup places six sources in a hexagonal arrangement , which resembles the natural symmetry of crystals or snowflakes. The result is a highly symmetric pattern with radial balance. Circular wavefronts from each source overlap in a way that enhances symmetry. The pattern is closer to circular interference rings . Again, the resulting wave field is: \\[ U(x, y) = \\sum_{i=1}^{6} \\sin(k r_i) \\] As the number of sources increases, the circular symmetry improves and the pattern begins to resemble a central source surrounded by ripple rings. Summary In all three cases, the wave sources are distributed on a unit circle , forming a regular polygon. As the number of sources increases: The density of interference patterns increases. The pattern becomes more symmetric and circular . Interference becomes more constructive near the center . These simulations are based on the principle of wave superposition and illustrate how symmetry affects wave interactions. Extensions (Link to Google Collab Simulation) https://colab.research.google.com/drive/1MZGHTR9STk3OZIWyuUVt4DeySR8lZ-JC?authuser=0","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from multiple sources overlap in space, creating new wave patterns. On a water surface, this is easily observed when circular ripples from different points intersect, producing interference patterns . These patterns reveal: Constructive interference : where waves reinforce each other Destructive interference : where waves cancel each other Studying such patterns helps us understand: Superposition principle Phase relationships between waves Real-world wave interactions","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"We aim to simulate and analyze the interference pattern created by circular waves emitted from coherent point sources located at the vertices of a regular polygon .","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#theoretical-background","text":"","title":"Theoretical Background"},{"location":"1%20Physics/3%20Waves/Problem_1/#single-circular-wave","text":"The disturbance caused by a single point source at position \\( (x_0, y_0) \\) on the water surface is modeled by: \\[ u(x, y, t) = A \\cdot \\cos(kr - \\omega t + \\phi) \\] Where: \\( u(x, y, t) \\) : Displacement at position \\( (x, y) \\) and time \\( t \\) \\( A \\) : Amplitude \\( k = \\frac{2\\pi}{\\lambda} \\) : Wave number \\( \\lambda \\) : Wavelength \\( \\omega = 2\\pi f \\) : Angular frequency \\( f \\) : Frequency \\( r = \\sqrt{(x - x_0)^2 + (y - y_0)^2} \\) : Distance from source to point \\( \\phi \\) : Initial phase","title":"Single Circular Wave"},{"location":"1%20Physics/3%20Waves/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"If there are \\( N \\) identical, coherent wave sources, the total displacement at any point \\( (x, y) \\) is: \\[ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Where: \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) : Distance from the \\( i^\\text{th} \\) source to point \\( (x, y) \\)","title":"Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-square-configuration-4-sources","text":"We simulate 4 point sources placed at the vertices of a square , centered at the origin.","title":"Simulation: Square Configuration (4 Sources)"},{"location":"1%20Physics/3%20Waves/Problem_1/#simulation-parameters","text":"Polygon type: Square (4 vertices) Radius \\( R = 1 \\) Amplitude \\( A = 1 \\) Wavelength \\( \\lambda = 1 \\) Frequency \\( f = 1 \\) Phase \\( \\phi = 0 \\) Time snapshot \\( t = 0 \\)","title":"Simulation Parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code","text":"The following Python script simulates the interference pattern produced by four coherent wave sources placed at the vertices of a square , centered at the origin. Each source emits circular waves with the same amplitude, wavelength, and frequency. The wave equation used for each point source is: \\[ u(x, y, t) = A \\cdot \\cos(k r - \\omega t + \\phi) \\] The total displacement is calculated by the superposition of waves from all sources: \\[ u_{\\text{total}}(x, y, t) = \\sum_{i=1}^{N} A \\cdot \\cos(k r_i - \\omega t + \\phi) \\] Here\u2019s the full Python implementation: import numpy as np import matplotlib.pyplot as plt # Wave parameters A = 1 wavelength = 1 frequency = 1 k = 2 * np.pi / wavelength omega = 2 * np.pi * frequency phi = 0 t = 0 # single time snapshot # Grid setup x = np.linspace(-3, 3, 500) y = np.linspace(-3, 3, 500) X, Y = np.meshgrid(x, y) # Square: 4 vertices on a circle N = 4 R = 1 angles = np.linspace(0, 2*np.pi, N, endpoint=False) sources = [(R * np.cos(a), R * np.sin(a)) for a in angles] # Superposition of waves Z = np.zeros_like(X) for (x0, y0) in sources: r = np.sqrt((X - x0)**2 + (Y - y0)**2) Z += A * np.cos(k * r - omega * t + phi) # Plotting plt.figure(figsize=(8, 6)) plt.pcolormesh(X, Y, Z, shading='auto', cmap='RdBu') plt.colorbar(label='Water Surface Displacement $u(x, y)$') plt.scatter(*zip(*sources), color='black', marker='o', label='Sources') plt.title('Interference Pattern from 4 Point Sources (Square Configuration)') plt.xlabel('x') plt.ylabel('y') plt.legend() plt.axis('equal') plt.tight_layout() plt.show()","title":"Python Code"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-from-multiple-sources","text":"These plots show the interference patterns generated by point wave sources arranged in regular polygonal shapes. The constructive and destructive interference of sinusoidal waves produces these beautiful and symmetric patterns.","title":"Interference Patterns from Multiple Sources"},{"location":"1%20Physics/3%20Waves/Problem_1/#1-3-source-interference-pattern-equilateral-triangle","text":"This pattern results from three wave sources placed at the vertices of an equilateral triangle . Each source emits waves of the same frequency and amplitude. Interference occurs where waves overlap . The symmetry of the triangle creates a rotationally symmetric interference pattern. You observe both constructive (bright/red) and destructive (dark/blue) interference zones. There is no analytical formula for the full pattern, but each source contributes: \\[ U_i(x, y) = \\sin(k r_i) \\] where: - \\( r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2} \\) - \\( k \\) : wave number The total displacement is: \\[ U(x, y) = \\sum_{i=1}^{3} \\sin(k r_i) \\]","title":"1. 3-Source Interference Pattern (Equilateral Triangle)"},{"location":"1%20Physics/3%20Waves/Problem_1/#_2","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#2-5-source-interference-pattern-regular-pentagon","text":"In this case, five sources are placed evenly on a circle, forming a regular pentagon . More sources result in finer interference fringes . The structure exhibits fivefold symmetry . The increased number of waves introduces complex wavefront interactions . The superposition principle still applies: \\[ U(x, y) = \\sum_{i=1}^{5} \\sin(k r_i) \\] As \\( n \\) increases, the pattern becomes denser and more circular.","title":"2. 5-Source Interference Pattern (Regular Pentagon)"},{"location":"1%20Physics/3%20Waves/Problem_1/#3-6-source-interference-pattern-regular-hexagon","text":"This setup places six sources in a hexagonal arrangement , which resembles the natural symmetry of crystals or snowflakes. The result is a highly symmetric pattern with radial balance. Circular wavefronts from each source overlap in a way that enhances symmetry. The pattern is closer to circular interference rings . Again, the resulting wave field is: \\[ U(x, y) = \\sum_{i=1}^{6} \\sin(k r_i) \\] As the number of sources increases, the circular symmetry improves and the pattern begins to resemble a central source surrounded by ripple rings.","title":"\ud83d\udd37 3. 6-Source Interference Pattern (Regular Hexagon)"},{"location":"1%20Physics/3%20Waves/Problem_1/#_3","text":"","title":""},{"location":"1%20Physics/3%20Waves/Problem_1/#summary","text":"In all three cases, the wave sources are distributed on a unit circle , forming a regular polygon. As the number of sources increases: The density of interference patterns increases. The pattern becomes more symmetric and circular . Interference becomes more constructive near the center . These simulations are based on the principle of wave superposition and illustrate how symmetry affects wave interactions.","title":"Summary"},{"location":"1%20Physics/3%20Waves/Problem_1/#extensions","text":"(Link to Google Collab Simulation) https://colab.research.google.com/drive/1MZGHTR9STk3OZIWyuUVt4DeySR8lZ-JC?authuser=0","title":"Extensions"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 Simulating the Effects of the Lorentz Force Motivation The Lorentz force is a fundamental concept in electromagnetism and charged particle dynamics. It describes how a charged particle moves under the influence of electric and magnetic fields. The force is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\( \\vec{F} \\) is the total force on the particle \\( q \\) is the charge \\( \\vec{E} \\) is the electric field \\( \\vec{v} \\) is the velocity of the particle \\( \\vec{B} \\) is the magnetic field The Lorentz force governs the motion of charged particles in a variety of physical systems, including: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement in fusion devices (e.g., tokamaks) Astrophysical environments (e.g., solar wind, magnetospheres) Applications of the Lorentz Force Particle Accelerators Charged particles are steered and accelerated using magnetic and electric fields based on Lorentz force dynamics. Mass Spectrometers Particles with different mass-to-charge ratios follow different curved paths in a magnetic field, enabling identification. Plasma Confinement Magnetic fields are used to confine hot plasmas in devices like tokamaks , where charged particles spiral and drift in controlled ways. Theory and Equations of Motion The motion of a charged particle under Lorentz force follows Newton's second law: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This is a system of coupled differential equations that can be solved numerically using methods like Euler's method or Runge-Kutta . Python Simulation: Lorentz Force We simulate three cases: Uniform Magnetic Field (Only \\( \\vec{B} \\) ) Combined Uniform Electric and Magnetic Fields Crossed \\( \\vec{E} \\perp \\vec{B} \\) Fields Parameters: Charge \\( q = 1 \\) C Mass \\( m = 1 \\) kg Initial velocity \\( \\vec{v}_0 = (v_x, v_y, v_z) \\) Fields: \\( \\vec{B} = (0, 0, B_z) \\) \\( \\vec{E} = (E_x, 0, 0) \\) Euler Integration Function import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, m, E, B, v0, r0, dt, steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt return r, v Interactive Lorentz Force Simulations Explore these online tools to interactively understand the Lorentz force: PhET: Charges and Fields Falstad: Magnetic Field Force Simulator MyPhysicsLab: Lorentz Force These visual tools can help you explore the vector nature of force, circular motion in B-fields, and drift dynamics in crossed fields.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force is a fundamental concept in electromagnetism and charged particle dynamics. It describes how a charged particle moves under the influence of electric and magnetic fields. The force is given by: \\[ \\vec{F} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] Where: \\( \\vec{F} \\) is the total force on the particle \\( q \\) is the charge \\( \\vec{E} \\) is the electric field \\( \\vec{v} \\) is the velocity of the particle \\( \\vec{B} \\) is the magnetic field The Lorentz force governs the motion of charged particles in a variety of physical systems, including: Particle accelerators (e.g., cyclotrons, synchrotrons) Mass spectrometers Plasma confinement in fusion devices (e.g., tokamaks) Astrophysical environments (e.g., solar wind, magnetospheres)","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#applications-of-the-lorentz-force","text":"Particle Accelerators Charged particles are steered and accelerated using magnetic and electric fields based on Lorentz force dynamics. Mass Spectrometers Particles with different mass-to-charge ratios follow different curved paths in a magnetic field, enabling identification. Plasma Confinement Magnetic fields are used to confine hot plasmas in devices like tokamaks , where charged particles spiral and drift in controlled ways.","title":"Applications of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#theory-and-equations-of-motion","text":"The motion of a charged particle under Lorentz force follows Newton's second law: \\[ m \\frac{d\\vec{v}}{dt} = q (\\vec{E} + \\vec{v} \\times \\vec{B}) \\] This is a system of coupled differential equations that can be solved numerically using methods like Euler's method or Runge-Kutta .","title":"Theory and Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-simulation-lorentz-force","text":"We simulate three cases: Uniform Magnetic Field (Only \\( \\vec{B} \\) ) Combined Uniform Electric and Magnetic Fields Crossed \\( \\vec{E} \\perp \\vec{B} \\) Fields","title":"Python Simulation: Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#parameters","text":"Charge \\( q = 1 \\) C Mass \\( m = 1 \\) kg Initial velocity \\( \\vec{v}_0 = (v_x, v_y, v_z) \\) Fields: \\( \\vec{B} = (0, 0, B_z) \\) \\( \\vec{E} = (E_x, 0, 0) \\)","title":"Parameters:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#euler-integration-function","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D def lorentz_force(q, m, E, B, v0, r0, dt, steps): r = np.zeros((steps, 3)) v = np.zeros((steps, 3)) r[0] = r0 v[0] = v0 for i in range(steps - 1): F = q * (E + np.cross(v[i], B)) a = F / m v[i + 1] = v[i] + a * dt r[i + 1] = r[i] + v[i] * dt return r, v","title":"Euler Integration Function"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#interactive-lorentz-force-simulations","text":"Explore these online tools to interactively understand the Lorentz force: PhET: Charges and Fields Falstad: Magnetic Field Force Simulator MyPhysicsLab: Lorentz Force These visual tools can help you explore the vector nature of force, circular motion in B-fields, and drift dynamics in crossed fields.","title":"Interactive Lorentz Force Simulations"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation Calculating equivalent resistance is a fundamental problem in analyzing electrical circuits. While it's easy to reduce simple circuits using series and parallel rules, this becomes extremely difficult for large or nested resistor networks. Graph theory offers a powerful, systematic approach for simplifying electrical circuits. In this approach: Nodes represent junctions Edges represent resistors , with edge weights as resistance values This allows for automated reduction and enables complex real-world applications such as: Electrical network simulation Optimization of energy efficiency Real-time fault diagnosis Integration into circuit design software Theoretical Framework We represent a circuit as an undirected graph : Each edge is a resistor with resistance \\( R \\in \\mathbb{R}^+ \\) Each node is a junction or connection point To simplify the circuit, we use: Series Rule If a node has degree 2 (i.e. connected to only two other nodes), and it's not a terminal node, then the resistors connected to it are in series: \\[ R_{\\text{eq}} = R_1 + R_2 \\] Parallel Rule If two or more resistors connect the same pair of nodes , they are in parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\sum_{i=1}^n \\frac{1}{R_i} \\] Graph Simplification Algorithm We reduce the graph step by step: Identify nodes of degree 2 and combine adjacent edges using the series rule Detect parallel edges between the same nodes and combine them using the parallel rule Repeat until the graph contains a single edge between the source and the target node Python Implementation (Task 2) Below is the full Python implementation using networkx for graph modeling and matplotlib for visualization. import networkx as nx import matplotlib.pyplot as plt def draw_graph(G, title=\"Circuit Graph\"): pos = nx.spring_layout(G) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(title) plt.show() def simplify_circuit(G): changed = True while changed: changed = False # Series reduction for node in list(G.nodes): if G.degree[node] == 2 and len(G.nodes) > 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: r1 = G[node][neighbors[0]]['resistance'] r2 = G[node][neighbors[1]]['resistance'] req = r1 + r2 G.add_edge(neighbors[0], neighbors[1], resistance=req) G.remove_node(node) changed = True break # Parallel reduction to_merge = {} for u, v, data in G.edges(data=True): key = tuple(sorted((u, v))) if key in to_merge: to_merge[key].append(data['resistance']) else: to_merge[key] = [data['resistance']] for (u, v), resistors in to_merge.items(): if len(resistors) > 1: inv_total = sum(1 / r for r in resistors) req = 1 / inv_total if inv_total != 0 else float('inf') G.remove_edges_from([(u, v)] * len(resistors)) G.add_edge(u, v, resistance=req) changed = True break return G def equivalent_resistance(G, source, target): if G.has_edge(source, target): return G[source][target]['resistance'] return float('inf') Examples & Results Example 1: Simple Series G1 = nx.Graph() G1.add_edge('A', 'B', resistance=5) G1.add_edge('B', 'C', resistance=10) draw_graph(G1, \"Before: Series Combination\") simplified_G1 = simplify_circuit(G1) draw_graph(simplified_G1, \"After: Series Reduced\") print(\"Equivalent Resistance (A\u2013C):\", equivalent_resistance(simplified_G1, 'A', 'C'), \"\u03a9\") Series Circuit: A-B-C This is a series circuit with three nodes: A , B , and C . The connections and resistances between nodes are as follows: From A to B : resistance \\( R_{AB} = 5 \\, \\Omega \\) From B to C : resistance \\( R_{BC} = 10 \\, \\Omega \\) The total resistance \\( R_{total} \\) in a series circuit is calculated as: \\[ R_{total} = R_{AB} + R_{BC} = 5 \\, \\Omega + 10 \\, \\Omega = 15 \\, \\Omega \\] Characteristics of a Series Circuit The same current flows through all components. The total resistance is the sum of all resistances. The voltage is divided based on each component's resistance. Example 2: Simple Parallel G2 = nx.MultiGraph() G2.add_edge('A', 'B', resistance=6) G2.add_edge('A', 'B', resistance=3) G2 = nx.Graph(G2) draw_graph(G2, \"Before: Parallel Combination\") simplified_G2 = simplify_circuit(G2) draw_graph(simplified_G2, \"After: Parallel Reduced\") print(\"Equivalent Resistance (A\u2013B):\", equivalent_resistance(simplified_G2, 'A', 'B'), \"\u03a9\") Parallel Resistors: A \u2194 B This is a parallel circuit with multiple resistors connecting node A to node B . Each branch has a resistance of: \\( R = 3 \\, \\Omega \\) If there are \\( n \\) such resistors in parallel, the total resistance \\( R_{total} \\) is calculated using the formula: \\[ \\frac{1}{R_{total}} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\] For example, with two resistors of \\( 3 \\, \\Omega \\) in parallel: \\[ \\frac{1}{R_{total}} = \\frac{1}{3} + \\frac{1}{3} = \\frac{2}{3} \\quad \\Rightarrow \\quad R_{total} = \\frac{3}{2} = 1.5 \\, \\Omega \\] Key Properties of Parallel Circuits: Voltage is the same across all branches. Total resistance decreases with more branches. Current divides among the paths based on resistance values. Example 3: Nested Combination G3 = nx.MultiGraph() G3.add_edge('A', 'B', resistance=2) G3.add_edge('B', 'C', resistance=4) G3.add_edge('B', 'C', resistance=4) G3.add_edge('C', 'D', resistance=2) G3 = nx.Graph(G3) draw_graph(G3, \"Before: Nested Circuit\") simplified_G3 = simplify_circuit(G3) draw_graph(simplified_G3, \"After: Nested Reduced\") print(\"Equivalent Resistance (A\u2013D):\", equivalent_resistance(simplified_G3, 'A', 'D'), \"\u03a9\") Nested Resistor Network: Series + Parallel This network consists of resistors between nodes: \\( R_{AB} = 2\\, \\Omega \\) \\( R_{BC} = 4\\, \\Omega \\) \\( R_{CD} = 2\\, \\Omega \\) Assuming a series connection , the total resistance is: \\[ R_{total} = R_{AB} + R_{BC} + R_{CD} = 2 + 4 + 2 = 8 \\, \\Omega \\] Key Series Circuit Properties: Same current through all resistors Total resistance is the sum Voltage divides among resistors If Node C had a parallel branch: Suppose another resistor \\( R_{CE} \\) (e.g., \\( 4\\, \\Omega \\) ) connected to a new node, E. Then C would form a junction, creating a parallel segment , and you'd calculate it like: \\[ \\frac{1}{R_{parallel}} = \\frac{1}{R_{CD}} + \\frac{1}{R_{CE}} \\] Then plug that back into the total series path. Additional Interactive Resources These tools allow you to build, explore, and analyze resistor circuits beyond theoretical models: Tinkercad Circuits Wolfram: Equivalent Resistance Explorer DCACLab Circuit Builder","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"Calculating equivalent resistance is a fundamental problem in analyzing electrical circuits. While it's easy to reduce simple circuits using series and parallel rules, this becomes extremely difficult for large or nested resistor networks. Graph theory offers a powerful, systematic approach for simplifying electrical circuits. In this approach: Nodes represent junctions Edges represent resistors , with edge weights as resistance values This allows for automated reduction and enables complex real-world applications such as: Electrical network simulation Optimization of energy efficiency Real-time fault diagnosis Integration into circuit design software","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#theoretical-framework","text":"We represent a circuit as an undirected graph : Each edge is a resistor with resistance \\( R \\in \\mathbb{R}^+ \\) Each node is a junction or connection point To simplify the circuit, we use:","title":"Theoretical Framework"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-rule","text":"If a node has degree 2 (i.e. connected to only two other nodes), and it's not a terminal node, then the resistors connected to it are in series: \\[ R_{\\text{eq}} = R_1 + R_2 \\]","title":"Series Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-rule","text":"If two or more resistors connect the same pair of nodes , they are in parallel: \\[ \\frac{1}{R_{\\text{eq}}} = \\sum_{i=1}^n \\frac{1}{R_i} \\]","title":"Parallel Rule"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-simplification-algorithm","text":"We reduce the graph step by step: Identify nodes of degree 2 and combine adjacent edges using the series rule Detect parallel edges between the same nodes and combine them using the parallel rule Repeat until the graph contains a single edge between the source and the target node","title":"Graph Simplification Algorithm"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation-task-2","text":"Below is the full Python implementation using networkx for graph modeling and matplotlib for visualization. import networkx as nx import matplotlib.pyplot as plt def draw_graph(G, title=\"Circuit Graph\"): pos = nx.spring_layout(G) edge_labels = nx.get_edge_attributes(G, 'resistance') nx.draw(G, pos, with_labels=True, node_color='lightblue', node_size=1000) nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels) plt.title(title) plt.show() def simplify_circuit(G): changed = True while changed: changed = False # Series reduction for node in list(G.nodes): if G.degree[node] == 2 and len(G.nodes) > 2: neighbors = list(G.neighbors(node)) if len(neighbors) == 2: r1 = G[node][neighbors[0]]['resistance'] r2 = G[node][neighbors[1]]['resistance'] req = r1 + r2 G.add_edge(neighbors[0], neighbors[1], resistance=req) G.remove_node(node) changed = True break # Parallel reduction to_merge = {} for u, v, data in G.edges(data=True): key = tuple(sorted((u, v))) if key in to_merge: to_merge[key].append(data['resistance']) else: to_merge[key] = [data['resistance']] for (u, v), resistors in to_merge.items(): if len(resistors) > 1: inv_total = sum(1 / r for r in resistors) req = 1 / inv_total if inv_total != 0 else float('inf') G.remove_edges_from([(u, v)] * len(resistors)) G.add_edge(u, v, resistance=req) changed = True break return G def equivalent_resistance(G, source, target): if G.has_edge(source, target): return G[source][target]['resistance'] return float('inf')","title":"Python Implementation (Task 2)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#examples-results","text":"","title":"Examples &amp; Results"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-1-simple-series","text":"G1 = nx.Graph() G1.add_edge('A', 'B', resistance=5) G1.add_edge('B', 'C', resistance=10) draw_graph(G1, \"Before: Series Combination\") simplified_G1 = simplify_circuit(G1) draw_graph(simplified_G1, \"After: Series Reduced\") print(\"Equivalent Resistance (A\u2013C):\", equivalent_resistance(simplified_G1, 'A', 'C'), \"\u03a9\")","title":"Example 1: Simple Series"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-circuit-a-b-c","text":"This is a series circuit with three nodes: A , B , and C . The connections and resistances between nodes are as follows: From A to B : resistance \\( R_{AB} = 5 \\, \\Omega \\) From B to C : resistance \\( R_{BC} = 10 \\, \\Omega \\) The total resistance \\( R_{total} \\) in a series circuit is calculated as: \\[ R_{total} = R_{AB} + R_{BC} = 5 \\, \\Omega + 10 \\, \\Omega = 15 \\, \\Omega \\]","title":"Series Circuit: A-B-C"},{"location":"1%20Physics/5%20Circuits/Problem_1/#characteristics-of-a-series-circuit","text":"The same current flows through all components. The total resistance is the sum of all resistances. The voltage is divided based on each component's resistance.","title":"Characteristics of a Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-2-simple-parallel","text":"G2 = nx.MultiGraph() G2.add_edge('A', 'B', resistance=6) G2.add_edge('A', 'B', resistance=3) G2 = nx.Graph(G2) draw_graph(G2, \"Before: Parallel Combination\") simplified_G2 = simplify_circuit(G2) draw_graph(simplified_G2, \"After: Parallel Reduced\") print(\"Equivalent Resistance (A\u2013B):\", equivalent_resistance(simplified_G2, 'A', 'B'), \"\u03a9\")","title":"Example 2: Simple Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-resistors-a-b","text":"This is a parallel circuit with multiple resistors connecting node A to node B . Each branch has a resistance of: \\( R = 3 \\, \\Omega \\) If there are \\( n \\) such resistors in parallel, the total resistance \\( R_{total} \\) is calculated using the formula: \\[ \\frac{1}{R_{total}} = \\sum_{i=1}^{n} \\frac{1}{R_i} \\] For example, with two resistors of \\( 3 \\, \\Omega \\) in parallel: \\[ \\frac{1}{R_{total}} = \\frac{1}{3} + \\frac{1}{3} = \\frac{2}{3} \\quad \\Rightarrow \\quad R_{total} = \\frac{3}{2} = 1.5 \\, \\Omega \\]","title":"Parallel Resistors: A \u2194 B"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-properties-of-parallel-circuits","text":"Voltage is the same across all branches. Total resistance decreases with more branches. Current divides among the paths based on resistance values.","title":"Key Properties of Parallel Circuits:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#example-3-nested-combination","text":"G3 = nx.MultiGraph() G3.add_edge('A', 'B', resistance=2) G3.add_edge('B', 'C', resistance=4) G3.add_edge('B', 'C', resistance=4) G3.add_edge('C', 'D', resistance=2) G3 = nx.Graph(G3) draw_graph(G3, \"Before: Nested Circuit\") simplified_G3 = simplify_circuit(G3) draw_graph(simplified_G3, \"After: Nested Reduced\") print(\"Equivalent Resistance (A\u2013D):\", equivalent_resistance(simplified_G3, 'A', 'D'), \"\u03a9\")","title":"Example 3: Nested Combination"},{"location":"1%20Physics/5%20Circuits/Problem_1/#nested-resistor-network-series-parallel","text":"This network consists of resistors between nodes: \\( R_{AB} = 2\\, \\Omega \\) \\( R_{BC} = 4\\, \\Omega \\) \\( R_{CD} = 2\\, \\Omega \\) Assuming a series connection , the total resistance is: \\[ R_{total} = R_{AB} + R_{BC} + R_{CD} = 2 + 4 + 2 = 8 \\, \\Omega \\]","title":"Nested Resistor Network: Series + Parallel"},{"location":"1%20Physics/5%20Circuits/Problem_1/#key-series-circuit-properties","text":"Same current through all resistors Total resistance is the sum Voltage divides among resistors","title":"Key Series Circuit Properties:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#if-node-c-had-a-parallel-branch","text":"Suppose another resistor \\( R_{CE} \\) (e.g., \\( 4\\, \\Omega \\) ) connected to a new node, E. Then C would form a junction, creating a parallel segment , and you'd calculate it like: \\[ \\frac{1}{R_{parallel}} = \\frac{1}{R_{CD}} + \\frac{1}{R_{CE}} \\] Then plug that back into the total series path.","title":"If Node C had a parallel branch:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#additional-interactive-resources","text":"These tools allow you to build, explore, and analyze resistor circuits beyond theoretical models: Tinkercad Circuits Wolfram: Equivalent Resistance Explorer DCACLab Circuit Builder","title":"Additional Interactive Resources"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 ## Exploring the Central Limit Theorem through Simulations Motivation The Central Limit Theorem (CLT) is one of the most important concepts in statistics. It states that: If you take sufficiently large random samples from any population (with finite mean and variance), the distribution of the sample means will tend toward a normal distribution. Mathematically: Let \\( X_1, X_2, \\dots, X_n \\) be i.i.d. random variables from a population with mean \\( \\mu \\) and variance \\( \\sigma^2 \\) . Then the sample mean: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] Will follow approximately: \\[ \\bar{X}_n \\sim \\mathcal{N}\\left( \\mu, \\frac{\\sigma^2}{n} \\right) \\] as \\( n \\to \\infty \\) , regardless of the original distribution of \\( X \\) . Simulating this process offers a powerful and intuitive demonstration of how and why the CLT works. Task Overview 1. Simulate populations from: Uniform distribution Exponential distribution Binomial distribution 2. For each: Sample means with \\( n = 5, 10, 30, 50 \\) Repeat sampling 5,000 times Plot histograms of sample means 3. Explore: Shape convergence to normal Effect of original variance Application in real-world contexts Python Code: CLT Simulation Engine import numpy as np import matplotlib.pyplot as plt import seaborn as sns def clt_simulation(population_func, sample_sizes, n_trials=5000, pop_size=100000, title=\"\"): \"\"\" Simulates the Central Limit Theorem: - population_func: function that returns a sample of size pop_size - sample_sizes: list of sample sizes (e.g., [5, 10, 30, 50]) - n_trials: how many sample means to compute per sample size - title: title to use in plots \"\"\" population = population_func(pop_size) true_mean = np.mean(population) true_std = np.std(population) print(f\"Population Mean: {true_mean:.2f}, Std Dev: {true_std:.2f}\") fig, axes = plt.subplots(1, len(sample_sizes), figsize=(18, 4)) for i, n in enumerate(sample_sizes): sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_trials)] sns.histplot(sample_means, kde=True, ax=axes[i], color=\"skyblue\", stat=\"density\") axes[i].set_title(f\"n = {n}\") axes[i].axvline(true_mean, color='red', linestyle='--', label='True Mean') axes[i].legend() axes[i].set_xlabel(\"Sample Mean\") axes[i].set_ylabel(\"Density\") fig.suptitle(f\"CLT Simulation: {title}\", fontsize=16) plt.tight_layout() plt.show() Example 1 Uniform Distribition clt_simulation( population_func=lambda n: np.random.uniform(0, 1, n), sample_sizes=[5, 10, 30, 50], title=\"Uniform(0, 1)\" ) Example 2 Exponential Distribition clt_simulation( population_func=lambda n: np.random.exponential(scale=1.0, size=n), sample_sizes=[5, 10, 30, 50], title=\"Exponential(\u03bb = 1)\" ) Example 3 Binomial Distribition clt_simulation( population_func=lambda n: np.random.binomial(n=10, p=0.5, size=n), sample_sizes=[5, 10, 30, 50], title=\"Binomial(n=10, p=0.5)\" ) Interactive CLT Simulations Want to explore CLT hands-on? Try these simulations: Seeing Theory \u2013 CLT Visualizer StatKey \u2013 Sample Mean Simulation Desmos CLT Graph These tools let you adjust sample sizes, population shapes, and see how sample means evolve","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"## Exploring the Central Limit Theorem through Simulations","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is one of the most important concepts in statistics. It states that: If you take sufficiently large random samples from any population (with finite mean and variance), the distribution of the sample means will tend toward a normal distribution. Mathematically: Let \\( X_1, X_2, \\dots, X_n \\) be i.i.d. random variables from a population with mean \\( \\mu \\) and variance \\( \\sigma^2 \\) . Then the sample mean: \\[ \\bar{X}_n = \\frac{1}{n} \\sum_{i=1}^{n} X_i \\] Will follow approximately: \\[ \\bar{X}_n \\sim \\mathcal{N}\\left( \\mu, \\frac{\\sigma^2}{n} \\right) \\] as \\( n \\to \\infty \\) , regardless of the original distribution of \\( X \\) . Simulating this process offers a powerful and intuitive demonstration of how and why the CLT works.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_1/#task-overview","text":"","title":"Task Overview"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-simulate-populations-from","text":"Uniform distribution Exponential distribution Binomial distribution","title":"1. Simulate populations from:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-for-each","text":"Sample means with \\( n = 5, 10, 30, 50 \\) Repeat sampling 5,000 times Plot histograms of sample means","title":"2. For each:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-explore","text":"Shape convergence to normal Effect of original variance Application in real-world contexts","title":"3. Explore:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#python-code-clt-simulation-engine","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns def clt_simulation(population_func, sample_sizes, n_trials=5000, pop_size=100000, title=\"\"): \"\"\" Simulates the Central Limit Theorem: - population_func: function that returns a sample of size pop_size - sample_sizes: list of sample sizes (e.g., [5, 10, 30, 50]) - n_trials: how many sample means to compute per sample size - title: title to use in plots \"\"\" population = population_func(pop_size) true_mean = np.mean(population) true_std = np.std(population) print(f\"Population Mean: {true_mean:.2f}, Std Dev: {true_std:.2f}\") fig, axes = plt.subplots(1, len(sample_sizes), figsize=(18, 4)) for i, n in enumerate(sample_sizes): sample_means = [np.mean(np.random.choice(population, size=n)) for _ in range(n_trials)] sns.histplot(sample_means, kde=True, ax=axes[i], color=\"skyblue\", stat=\"density\") axes[i].set_title(f\"n = {n}\") axes[i].axvline(true_mean, color='red', linestyle='--', label='True Mean') axes[i].legend() axes[i].set_xlabel(\"Sample Mean\") axes[i].set_ylabel(\"Density\") fig.suptitle(f\"CLT Simulation: {title}\", fontsize=16) plt.tight_layout() plt.show()","title":"Python Code: CLT Simulation Engine"},{"location":"1%20Physics/6%20Statistics/Problem_1/#example-1","text":"","title":"Example 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#uniform-distribition","text":"clt_simulation( population_func=lambda n: np.random.uniform(0, 1, n), sample_sizes=[5, 10, 30, 50], title=\"Uniform(0, 1)\" )","title":"Uniform Distribition"},{"location":"1%20Physics/6%20Statistics/Problem_1/#example-2","text":"","title":"Example 2"},{"location":"1%20Physics/6%20Statistics/Problem_1/#exponential-distribition","text":"clt_simulation( population_func=lambda n: np.random.exponential(scale=1.0, size=n), sample_sizes=[5, 10, 30, 50], title=\"Exponential(\u03bb = 1)\" )","title":"Exponential Distribition"},{"location":"1%20Physics/6%20Statistics/Problem_1/#example-3","text":"","title":"Example 3"},{"location":"1%20Physics/6%20Statistics/Problem_1/#binomial-distribition","text":"clt_simulation( population_func=lambda n: np.random.binomial(n=10, p=0.5, size=n), sample_sizes=[5, 10, 30, 50], title=\"Binomial(n=10, p=0.5)\" )","title":"Binomial Distribition"},{"location":"1%20Physics/6%20Statistics/Problem_1/#interactive-clt-simulations","text":"Want to explore CLT hands-on? Try these simulations: Seeing Theory \u2013 CLT Visualizer StatKey \u2013 Sample Mean Simulation Desmos CLT Graph These tools let you adjust sample sizes, population shapes, and see how sample means evolve","title":"Interactive CLT Simulations"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \\( \\pi \\) Using Monte Carlo Methods Motivation The number \\( \\pi \\) is one of the most important constants in mathematics, appearing in geometry, calculus, physics, engineering, and probability. While it is typically calculated using analytical or series methods, it can also be estimated using randomness via Monte Carlo simulations . Monte Carlo methods use repeated random sampling to obtain numerical estimates. One particularly elegant application is the estimation of \\( \\pi \\) through: Geometric probability : simulating random points inside a square and counting how many fall within an inscribed circle. Buffon\u2019s Needle : a probability problem from the 18th century involving the likelihood that a needle crosses lines on a floor. These approaches demonstrate how randomness can approximate precise mathematical values and give us insights into convergence, error, and simulation design. Part 1: Estimating \\( \\pi \\) Using a Circle Theoretical Foundation Imagine a unit circle (radius \\( r = 1 \\) ) inscribed within a square of side length 2 (from \\(-1\\) to \\(1\\) along both axes). The area of the square is: $$ A_{\\text{square}} = (2r)^2 = 4 $$ The area of the circle is: $$ A_{\\text{circle}} = \\pi r^2 = \\pi $$ The ratio of the circle's area to the square\u2019s area is: $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} $$ So, if we generate random points uniformly in the square and count the fraction that fall inside the circle (i.e., satisfy \\( x^2 + y^2 \\leq 1 \\) ), we can estimate \\( \\pi \\) by: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\] Simulation Steps Generate \\( N \\) random points in the square \\([-1, 1] \\times [-1, 1]\\) Count how many fall inside the unit circle Apply the formula above to estimate \\( \\pi \\) ----- What is The Monte Carlo Method The Monte Carlo method is a numerical approach that uses random sampling to solve mathematical problems that may be deterministic or probabilistic in nature. Basic Principle To estimate a quantity \\( Q \\) , perform many random experiments and take the average result: \\[ Q \\approx \\frac{1}{N} \\sum_{i=1}^{N} f(x_i) \\] Where: - \\( N \\) : number of random samples - \\( x_i \\) : randomly sampled inputs - \\( f(x_i) \\) : the function evaluated at \\( x_i \\) Example: Estimating \\( \\pi \\) Generate \\( N \\) random points in the unit square \\([0, 1] \\times [0, 1]\\) Count how many fall inside the quarter-circle of radius 1: \\[ \\text{if } x^2 + y^2 \\leq 1 \\text{, it's inside} \\] Then approximate \\( \\pi \\) as: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Number of points inside circle}}{N} \\] Applications Physics : Particle transport, statistical mechanics Finance : Option pricing, risk analysis Engineering : Reliability simulations Mathematics : Multidimensional integrals Key Advantages Handles high-dimensional problems Easy to implement Scales well with computational power Limitations Convergence is slow ( \\( \\propto \\frac{1}{\\sqrt{N}} \\) ) Needs a large number of samples for high accuracy Visualization We can visualize this method by plotting: - Points inside the circle (where \\( x^2 + y^2 \\leq 1 \\) ) - Points outside the circle but within the square Convergence Analysis By increasing the number of points, we should observe: - The estimate converges closer to the true value of \\( \\pi \\) - The variance of estimates decreases Theoretically, the standard error of this method decreases as: \\[ \\text{Error} \\propto \\frac{1}{\\sqrt{N}} \\] Part 2: Estimating \\( \\pi \\) Using Buffon\u2019s Needle Theoretical Foundation Buffon\u2019s Needle is a classical probability problem: - Drop a needle of length \\( L \\) onto a plane with equally spaced horizontal lines \\( d \\) units apart (with \\( L \\leq d \\) ). - The probability \\( P \\) that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] From this, we can estimate \\( \\pi \\) using: \\[ \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: - \\( N \\) is the number of needle drops - \\( C \\) is the number of times the needle crosses a line Simulation Steps Simulate random needle drops: Randomly choose the needle center position Randomly choose its angle Count how many needles cross a line Estimate \\( \\pi \\) using the formula above ----- What is The Buffon's Needle Method Buffon\u2019s Needle is a probabilistic method for estimating \\( \\pi \\) by simulating needle drops onto a surface with parallel lines. Setup Needle length: \\( L \\) Distance between lines: \\( D \\) \\( L \\leq D \\) Drop the needle \\( N \\) times Let \\( H \\) be the number of times the needle crosses a line. Theoretical Probability The probability that a needle crosses a line is: \\[ P = \\frac{2L}{\\pi D} \\] Estimating \\( \\pi \\) By observing the experimental crossing rate: \\[ \\pi \\approx \\frac{2L \\cdot N}{D \\cdot H} \\] Where: - \\( N \\) : number of total trials - \\( H \\) : number of hits (crossings) Application This method is a classic Monte Carlo simulation that uses geometric probability to estimate \u03c0. It\u2019s also a great demonstration of how randomness can solve complex mathematical problems. Visualization In a graphical simulation, we can show: - Needles as line segments - Horizontal lines they may cross - Highlight needles that cross the lines This provides an intuitive understanding of the randomness and geometry involved. Convergence Behavior Buffon\u2019s Needle converges more slowly than the circle method because: - The crossing condition is more specific and less frequently triggered - Variance in estimation is higher It still demonstrates the power of geometric probability in estimating \\( \\pi \\) . Comparison of Methods Method Formula Speed Accuracy Visualization Circle Monte Carlo \\( \\pi \\approx 4 \\cdot \\frac{\\text{Inside}}{\\text{Total}} \\) Fast Good 2D scatter plot Buffon\u2019s Needle \\( \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\) Slower Noisier Needle over lines Key Insights Both methods rely on random sampling and geometry . Increasing the number of trials improves the accuracy. Monte Carlo methods offer visual and intuitive ways to estimate mathematical constants. These ideas generalize to simulate complex systems in physics, biology, finance, and beyond . Extensions Try using different values of \\( L \\) and \\( d \\) in Buffon\u2019s Needle Estimate convergence rates numerically by plotting error vs. sample size Animate the simulation process to show convergence dynamically Use parallel computing to increase the number of trials Related Simulations (Interactive Tools) Visualize Monte Carlo Estimation of Pi \u2013 Seeing Theory Desmos \u2013 Pi Approximation (Monte Carlo) These tools help build intuition and reinforce the geometric probability interpretation of \\( \\pi \\) .","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"","title":"Estimating \\( \\pi \\) Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"The number \\( \\pi \\) is one of the most important constants in mathematics, appearing in geometry, calculus, physics, engineering, and probability. While it is typically calculated using analytical or series methods, it can also be estimated using randomness via Monte Carlo simulations . Monte Carlo methods use repeated random sampling to obtain numerical estimates. One particularly elegant application is the estimation of \\( \\pi \\) through: Geometric probability : simulating random points inside a square and counting how many fall within an inscribed circle. Buffon\u2019s Needle : a probability problem from the 18th century involving the likelihood that a needle crosses lines on a floor. These approaches demonstrate how randomness can approximate precise mathematical values and give us insights into convergence, error, and simulation design.","title":"Motivation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-pi-using-a-circle","text":"","title":"Part 1: Estimating \\( \\pi \\) Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation","text":"Imagine a unit circle (radius \\( r = 1 \\) ) inscribed within a square of side length 2 (from \\(-1\\) to \\(1\\) along both axes). The area of the square is: $$ A_{\\text{square}} = (2r)^2 = 4 $$ The area of the circle is: $$ A_{\\text{circle}} = \\pi r^2 = \\pi $$ The ratio of the circle's area to the square\u2019s area is: $$ \\frac{A_{\\text{circle}}}{A_{\\text{square}}} = \\frac{\\pi}{4} $$ So, if we generate random points uniformly in the square and count the fraction that fall inside the circle (i.e., satisfy \\( x^2 + y^2 \\leq 1 \\) ), we can estimate \\( \\pi \\) by: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Points in Circle}}{\\text{Total Points}} \\]","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-steps","text":"Generate \\( N \\) random points in the square \\([-1, 1] \\times [-1, 1]\\) Count how many fall inside the unit circle Apply the formula above to estimate \\( \\pi \\)","title":"Simulation Steps"},{"location":"1%20Physics/6%20Statistics/Problem_2/#-","text":"","title":"-----"},{"location":"1%20Physics/6%20Statistics/Problem_2/#what-is-the-monte-carlo-method","text":"The Monte Carlo method is a numerical approach that uses random sampling to solve mathematical problems that may be deterministic or probabilistic in nature.","title":"What is The Monte Carlo Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#basic-principle","text":"To estimate a quantity \\( Q \\) , perform many random experiments and take the average result: \\[ Q \\approx \\frac{1}{N} \\sum_{i=1}^{N} f(x_i) \\] Where: - \\( N \\) : number of random samples - \\( x_i \\) : randomly sampled inputs - \\( f(x_i) \\) : the function evaluated at \\( x_i \\)","title":"Basic Principle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#example-estimating-pi","text":"Generate \\( N \\) random points in the unit square \\([0, 1] \\times [0, 1]\\) Count how many fall inside the quarter-circle of radius 1: \\[ \\text{if } x^2 + y^2 \\leq 1 \\text{, it's inside} \\] Then approximate \\( \\pi \\) as: \\[ \\pi \\approx 4 \\cdot \\frac{\\text{Number of points inside circle}}{N} \\]","title":"Example: Estimating \\( \\pi \\)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#applications","text":"Physics : Particle transport, statistical mechanics Finance : Option pricing, risk analysis Engineering : Reliability simulations Mathematics : Multidimensional integrals","title":"Applications"},{"location":"1%20Physics/6%20Statistics/Problem_2/#key-advantages","text":"Handles high-dimensional problems Easy to implement Scales well with computational power","title":"Key Advantages"},{"location":"1%20Physics/6%20Statistics/Problem_2/#limitations","text":"Convergence is slow ( \\( \\propto \\frac{1}{\\sqrt{N}} \\) ) Needs a large number of samples for high accuracy","title":"Limitations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization","text":"We can visualize this method by plotting: - Points inside the circle (where \\( x^2 + y^2 \\leq 1 \\) ) - Points outside the circle but within the square","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-analysis","text":"By increasing the number of points, we should observe: - The estimate converges closer to the true value of \\( \\pi \\) - The variance of estimates decreases Theoretically, the standard error of this method decreases as: \\[ \\text{Error} \\propto \\frac{1}{\\sqrt{N}} \\]","title":"Convergence Analysis"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"Part 2: Estimating \\( \\pi \\) Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-foundation_1","text":"Buffon\u2019s Needle is a classical probability problem: - Drop a needle of length \\( L \\) onto a plane with equally spaced horizontal lines \\( d \\) units apart (with \\( L \\leq d \\) ). - The probability \\( P \\) that the needle crosses a line is: \\[ P = \\frac{2L}{\\pi d} \\] From this, we can estimate \\( \\pi \\) using: \\[ \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\] Where: - \\( N \\) is the number of needle drops - \\( C \\) is the number of times the needle crosses a line","title":"Theoretical Foundation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#simulation-steps_1","text":"Simulate random needle drops: Randomly choose the needle center position Randomly choose its angle Count how many needles cross a line Estimate \\( \\pi \\) using the formula above","title":"Simulation Steps"},{"location":"1%20Physics/6%20Statistics/Problem_2/#-_1","text":"","title":"-----"},{"location":"1%20Physics/6%20Statistics/Problem_2/#what-is-the-buffons-needle-method","text":"Buffon\u2019s Needle is a probabilistic method for estimating \\( \\pi \\) by simulating needle drops onto a surface with parallel lines.","title":"What is The Buffon's Needle Method"},{"location":"1%20Physics/6%20Statistics/Problem_2/#setup","text":"Needle length: \\( L \\) Distance between lines: \\( D \\) \\( L \\leq D \\) Drop the needle \\( N \\) times Let \\( H \\) be the number of times the needle crosses a line.","title":"Setup"},{"location":"1%20Physics/6%20Statistics/Problem_2/#theoretical-probability","text":"The probability that a needle crosses a line is: \\[ P = \\frac{2L}{\\pi D} \\]","title":"Theoretical Probability"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi","text":"By observing the experimental crossing rate: \\[ \\pi \\approx \\frac{2L \\cdot N}{D \\cdot H} \\] Where: - \\( N \\) : number of total trials - \\( H \\) : number of hits (crossings)","title":"Estimating \\( \\pi \\)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#application","text":"This method is a classic Monte Carlo simulation that uses geometric probability to estimate \u03c0. It\u2019s also a great demonstration of how randomness can solve complex mathematical problems.","title":"Application"},{"location":"1%20Physics/6%20Statistics/Problem_2/#visualization_1","text":"In a graphical simulation, we can show: - Needles as line segments - Horizontal lines they may cross - Highlight needles that cross the lines This provides an intuitive understanding of the randomness and geometry involved.","title":"Visualization"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-behavior","text":"Buffon\u2019s Needle converges more slowly than the circle method because: - The crossing condition is more specific and less frequently triggered - Variance in estimation is higher It still demonstrates the power of geometric probability in estimating \\( \\pi \\) .","title":"Convergence Behavior"},{"location":"1%20Physics/6%20Statistics/Problem_2/#comparison-of-methods","text":"Method Formula Speed Accuracy Visualization Circle Monte Carlo \\( \\pi \\approx 4 \\cdot \\frac{\\text{Inside}}{\\text{Total}} \\) Fast Good 2D scatter plot Buffon\u2019s Needle \\( \\pi \\approx \\frac{2L \\cdot N}{d \\cdot C} \\) Slower Noisier Needle over lines","title":"Comparison of Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#key-insights","text":"Both methods rely on random sampling and geometry . Increasing the number of trials improves the accuracy. Monte Carlo methods offer visual and intuitive ways to estimate mathematical constants. These ideas generalize to simulate complex systems in physics, biology, finance, and beyond .","title":"Key Insights"},{"location":"1%20Physics/6%20Statistics/Problem_2/#extensions","text":"Try using different values of \\( L \\) and \\( d \\) in Buffon\u2019s Needle Estimate convergence rates numerically by plotting error vs. sample size Animate the simulation process to show convergence dynamically Use parallel computing to increase the number of trials","title":"Extensions"},{"location":"1%20Physics/6%20Statistics/Problem_2/#related-simulations-interactive-tools","text":"Visualize Monte Carlo Estimation of Pi \u2013 Seeing Theory Desmos \u2013 Pi Approximation (Monte Carlo) These tools help build intuition and reinforce the geometric probability interpretation of \\( \\pi \\) .","title":"Related Simulations (Interactive Tools)"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity \\( g \\) is a fundamental constant of nature, affecting a wide range of physical phenomena, from falling objects to satellite orbits. Determining \\( g \\) experimentally allows us to connect theoretical physics to measurable reality. One of the most elegant and classical ways to measure \\( g \\) is with a simple pendulum , where the period of oscillation is directly related to the local gravitational field strength. Task Use a simple pendulum to estimate the gravitational acceleration \\( g \\) . Carefully measure time, length, and calculate uncertainties. Analyze the precision of your estimate and reflect on sources of error. Materials A string (approximately 1\u20131.5 meters in length) A small mass (e.g., keychain, metal weight, bag of sugar) A stopwatch (or a smartphone timer) A ruler or measuring tape Procedure 1. Setup Attach the string to a fixed support and tie the mass to the other end. Measure the length \\( L \\) from the suspension point to the center of the mass. Record the ruler resolution , then calculate the uncertainty in length as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\] 2. Data Collection Displace the pendulum by a small angle (less than \\(15^\\circ\\) ) and release. Measure the time for 10 complete oscillations (denoted \\( T_{10} \\) ). Repeat this process 10 times , and record all measurements. Calculate the mean time \\( \\overline{T}_{10} \\) and the standard deviation \\( \\sigma_T \\) . Estimate the uncertainty in the mean using: $$ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\quad \\text{where } n = 10 $$ Calculations 1. Calculate the Period The period \\( T \\) of one oscillation is: \\[ T = \\frac{\\overline{T}_{10}}{10} \\] And its uncertainty: \\[ \\Delta T = \\frac{\\Delta T_{10}}{10} \\] 2. Calculate Gravitational Acceleration The formula for gravitational acceleration using a pendulum is: \\[ g = \\frac{4\\pi^2 L}{T^2} \\] 3. Propagate Uncertainties The uncertainty in \\( g \\) is calculated using propagation of uncertainty: \\[ \\Delta g = g \\cdot \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\] Example Table (Fill with Your Data) Trial \\( T_{10} \\) (s) 1 2 ... 10 Mean \\( \\overline{T}_{10} \\) = ... Standard deviation \\( \\sigma_T \\) = ... \\( T = \\overline{T}_{10} / 10 \\) = ... \\( L = \\) ... m \u00b1 \\( \\Delta L = \\) ... m \\( g = \\) ... m/s\u00b2 \u00b1 \\( \\Delta g = \\) ... Analysis 1. Comparison Compare your measured value of \\( g \\) with the standard value: \\[ g_{\\text{standard}} = 9.81 \\ \\text{m/s}^2 \\] 2. Discussion How does length resolution (i.e., \\( \\Delta L \\) ) affect the uncertainty in \\( g \\) ? How does timing variability (i.e., \\( \\Delta T \\) ) contribute to your final result? What sources of systematic or random error could influence your measurements? Deliverables Table of all \\( T_{10} \\) trials, length \\( L \\) , and uncertainties Calculated values: \\( \\overline{T}_{10} \\) , \\( T \\) , \\( g \\) , \\( \\Delta g \\) Discussion on uncertainties and comparison to the expected value Additional Notes Small angles (< \\(15^\\circ\\) ) are important to ensure the pendulum behaves like a simple harmonic oscillator . Repeating measurements reduces random error . The accuracy of your stopwatch and human reaction time are key contributors to the total uncertainty . Interactive Simulations Explore pendulum physics with these interactive tools: PhET \u2013 Pendulum Lab MyPhysicsLab \u2013 Pendulum Simulation GeoGebra \u2013 Simple Pendulum Desmos \u2013 Pendulum Curve These simulations let you experiment with pendulum length, gravity, damping, and observe how these affect the period and motion.","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity \\( g \\) is a fundamental constant of nature, affecting a wide range of physical phenomena, from falling objects to satellite orbits. Determining \\( g \\) experimentally allows us to connect theoretical physics to measurable reality. One of the most elegant and classical ways to measure \\( g \\) is with a simple pendulum , where the period of oscillation is directly related to the local gravitational field strength.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#task","text":"Use a simple pendulum to estimate the gravitational acceleration \\( g \\) . Carefully measure time, length, and calculate uncertainties. Analyze the precision of your estimate and reflect on sources of error.","title":"Task"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials","text":"A string (approximately 1\u20131.5 meters in length) A small mass (e.g., keychain, metal weight, bag of sugar) A stopwatch (or a smartphone timer) A ruler or measuring tape","title":"Materials"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-setup","text":"Attach the string to a fixed support and tie the mass to the other end. Measure the length \\( L \\) from the suspension point to the center of the mass. Record the ruler resolution , then calculate the uncertainty in length as: \\[ \\Delta L = \\frac{\\text{Ruler Resolution}}{2} \\]","title":"1. Setup"},{"location":"1%20Physics/7%20Measurements/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-data-collection","text":"Displace the pendulum by a small angle (less than \\(15^\\circ\\) ) and release. Measure the time for 10 complete oscillations (denoted \\( T_{10} \\) ). Repeat this process 10 times , and record all measurements. Calculate the mean time \\( \\overline{T}_{10} \\) and the standard deviation \\( \\sigma_T \\) . Estimate the uncertainty in the mean using: $$ \\Delta T_{10} = \\frac{\\sigma_T}{\\sqrt{n}} \\quad \\text{where } n = 10 $$","title":"2. Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#calculations","text":"","title":"Calculations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"The period \\( T \\) of one oscillation is: \\[ T = \\frac{\\overline{T}_{10}}{10} \\] And its uncertainty: \\[ \\Delta T = \\frac{\\Delta T_{10}}{10} \\]","title":"1. Calculate the Period"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-calculate-gravitational-acceleration","text":"The formula for gravitational acceleration using a pendulum is: \\[ g = \\frac{4\\pi^2 L}{T^2} \\]","title":"2. Calculate Gravitational Acceleration"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"The uncertainty in \\( g \\) is calculated using propagation of uncertainty: \\[ \\Delta g = g \\cdot \\sqrt{ \\left( \\frac{\\Delta L}{L} \\right)^2 + \\left( 2 \\cdot \\frac{\\Delta T}{T} \\right)^2 } \\]","title":"3. Propagate Uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#example-table-fill-with-your-data","text":"Trial \\( T_{10} \\) (s) 1 2 ... 10 Mean \\( \\overline{T}_{10} \\) = ... Standard deviation \\( \\sigma_T \\) = ... \\( T = \\overline{T}_{10} / 10 \\) = ... \\( L = \\) ... m \u00b1 \\( \\Delta L = \\) ... m \\( g = \\) ... m/s\u00b2 \u00b1 \\( \\Delta g = \\) ...","title":"Example Table (Fill with Your Data)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#analysis","text":"","title":"Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-comparison","text":"Compare your measured value of \\( g \\) with the standard value: \\[ g_{\\text{standard}} = 9.81 \\ \\text{m/s}^2 \\]","title":"1. Comparison"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-discussion","text":"How does length resolution (i.e., \\( \\Delta L \\) ) affect the uncertainty in \\( g \\) ? How does timing variability (i.e., \\( \\Delta T \\) ) contribute to your final result? What sources of systematic or random error could influence your measurements?","title":"2. Discussion"},{"location":"1%20Physics/7%20Measurements/Problem_1/#deliverables","text":"Table of all \\( T_{10} \\) trials, length \\( L \\) , and uncertainties Calculated values: \\( \\overline{T}_{10} \\) , \\( T \\) , \\( g \\) , \\( \\Delta g \\) Discussion on uncertainties and comparison to the expected value","title":"Deliverables"},{"location":"1%20Physics/7%20Measurements/Problem_1/#additional-notes","text":"Small angles (< \\(15^\\circ\\) ) are important to ensure the pendulum behaves like a simple harmonic oscillator . Repeating measurements reduces random error . The accuracy of your stopwatch and human reaction time are key contributors to the total uncertainty .","title":"Additional Notes"},{"location":"1%20Physics/7%20Measurements/Problem_1/#interactive-simulations","text":"Explore pendulum physics with these interactive tools: PhET \u2013 Pendulum Lab MyPhysicsLab \u2013 Pendulum Simulation GeoGebra \u2013 Simple Pendulum Desmos \u2013 Pendulum Curve These simulations let you experiment with pendulum length, gravity, damping, and observe how these affect the period and motion.","title":"Interactive Simulations"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}